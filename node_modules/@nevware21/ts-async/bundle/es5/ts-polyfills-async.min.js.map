{"version":3,"file":"ts-polyfills-async.min.js","sources":["https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/internal/treeshake_helpers.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/safe.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/base.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/has_own.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/has_own_prop.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/for_each_key.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/define.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/internal/map.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/diagnostics.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/throw.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/object.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/enum.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/internal/global.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/lazy.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/cache.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/environment.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/symbol/symbol.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/polyfills/symbol.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/iterator/iterator.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/iterator/forOf.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/funcs/funcs.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/array/forEach.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/array/slice.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/create.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/set_proto.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/helpers/customError.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/timer/timeout.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/timer/handler.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/await.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/event.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/base.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/asyncPromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/itemProcessor.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/internal/constants.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/constants.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/polyfills.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/object/get_own_prop_desc.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/string/as_string.ts","https://raw.githubusercontent.com/nevware21/ts-utils/refs/tags/0.11.6/lib/src/symbol/well_known.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/state.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/polyfills/promise.ts"],"sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal tree shaking helper to return the first available function from the two provided.\r\n * This is required to ensure that tree-shaking can remove any unused functions as this ensures\r\n * that the alias assignments are not considered side-effects and are tagged correctly as pure.\r\n * @param func1 - The system function to use if available\r\n * @param func2 - The polyfill function to use if the static function is not available\r\n * @returns The first available function from the two provided\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _pureAssign<F>(func1: F, func2?: F): F {\r\n    return func1 || func2;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal tree shaking helper to return the value of the named property from the provided object.\r\n * By using this helper, we can explicitly tell the tree-shaking tool that this function is pure and\r\n * has no side effects. As some tree-shaking tools may not be able to determine this automatically.\r\n * @param value - The object to get the property value from\r\n * @param name - The name of the property to get the value of\r\n * @returns The value of the named property from the provided object\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _pureRef<R extends T[keyof T], T = any>(value: T, name: keyof T): R {\r\n    return value[name] as R;\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/**\r\n * Infers the return type of the specified function\r\n * @since 0.10.5\r\n * @group Safe\r\n * @typeParam T - The type of the function which to infer the return type\r\n */\r\nexport type SafeReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any\r\n\r\n/**\r\n * Defines the return value of the {@link safe} function, which is an object with either a value or an error\r\n * @since 0.10.5\r\n * @group Safe\r\n * @typeParam T - The type of the function to call\r\n * @typeParam R - The return type of the function\r\n */\r\nexport interface ISafeReturn<T extends (...args: any) => any> {\r\n    /**\r\n     * The value returned by the function call\r\n     */\r\n    v?: SafeReturnType<T>;\r\n\r\n    /**\r\n     * The error thrown by the function call\r\n     */\r\n    e?: Error;\r\n}\r\n\r\n/**\r\n * Call the specified function with zero or more individual arguments, the call will be wrapped in a try / catch\r\n * block and the result returned wrapped in an {@link ISafeReturn} instance. If the function call throws an\r\n * exception the {@link ISafeReturn.e | error} property will contain the exception otherwise the {@link ISafeReturn.v | value}\r\n * property will contain the value returned from the function.\r\n * @since 0.10.5\r\n * @group Safe\r\n * @param func - The function to call\r\n * @param argArray - An array of the arguments to pass to the function\r\n * @returns The return value of the function or undefined if an exception is thrown\r\n * @example\r\n * ```ts\r\n * let result = safe((value: string) => {\r\n *    return JSON.parse(value);\r\n * }, [\"{ invalid: json value\"]);\r\n *\r\n * // result.e instanceof SyntaxError\r\n *\r\n * let result2 = safe((value: string) => {\r\n *   return JSON.parse(value);\r\n * }, [\"{ valid: 'json value' }\"]);\r\n *\r\n * // result2.v === { valid: \"json value\" }\r\n * ```\r\n */\r\nexport function safe<F extends (...args: unknown[]) => any>(func: F, argArray?: any[]): ISafeReturn<F> {\r\n    try {\r\n        return {\r\n            v: func.apply(this, argArray)\r\n        };\r\n    } catch (e) {\r\n        return { e };\r\n    }\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ArrCls, FUNCTION, NULL_VALUE, OBJECT, ObjProto, TO_STRING, UNDEFINED, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { _pureRef } from \"../internal/treeshake_helpers\";\r\nimport { safeGet } from \"./safe_get\";\r\n\r\nlet _primitiveTypes: string[];\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Create and returns a function that will return `true` if the argument passed\r\n * to it matches the provided type.\r\n * @param theType - The type to match against the `typeof value`\r\n * @returns A function which takes a single argument and returns a boolean\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createIs<T>(theType: string): (value: any) => value is T {\r\n    return function (value: any): value is T {\r\n        return typeof value === theType;\r\n    }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Create and returns a function that will return `true` if the argument passed\r\n * to it matches the object type specified based on {@link objToString}.\r\n * @param - The object name to match for the `objToString(value)`\r\n * @returns A function which takes a single argument and returns a boolean\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createObjIs<T>(theName: string): (value: any) => value is T {\r\n    const theType = \"[object \" + theName + \"]\";\r\n    return function (value: any): value is T {\r\n        return !!(value && objToString(value) === theType);\r\n    }\r\n}\r\n\r\n/**\r\n * The `objToString()` method returns a string representing the object. This explicitly\r\n * always calls the `Object.prototype.toString()` method.\r\n *\r\n * An object's toString() method is most commonly invoked when that object undergoes:\r\n * - explicit type conversion to a string (for example, String(myObject))\r\n * - implicit type coercion into a string (for example, myObject + \"hello world\")\r\n *\r\n * @group Object\r\n * @param value - The object to be converted into a string\r\n * @returns A string representation of the object\r\n * @example\r\n * ```ts\r\n * objToString(new Date()); // [object Date]\r\n * objToString(new String()); // [object String]\r\n *\r\n * // Math has its Symbol.toStringTag\r\n * objToString(Math); // [object Math]\r\n *\r\n * objToString(undefined); // [object Undefined]\r\n * objToString(null); // [object Null]\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function objToString(value: any): string {\r\n    return ObjProto[TO_STRING].call(value);\r\n}\r\n\r\n/**\r\n * Validate if the provided value object is of the expected type\r\n * @group Type Identity\r\n * @param value - The value to check\r\n * @param theType - The expected type name as a string\r\n * @returns `true` if the value matches the provided type\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isTypeof(value: any, theType: string): boolean {\r\n    return typeof value === theType;\r\n}\r\n\r\n/**\r\n * Checks if the provided value is undefined or contains the string value \"undefined\",\r\n * if you want to consider the string value as undefined see {@link isStrictUndefined}\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param value - The value to check\r\n * @returns true if the value is undefined or \"undefined\", otherwise false\r\n * @example\r\n * ```ts\r\n * isUndefined(undefined);              // true\r\n * isUndefined(\"undefined\");            // true\r\n *\r\n * isUndefined(null);                   // false\r\n * isUndefined(\"null\");                 // false\r\n * isUndefined(\"1\");                    // false\r\n * isUndefined(\"aa\");                   // false\r\n * isUndefined(new Date());             // false\r\n * isUndefined(1);                      // false\r\n * isUndefined(\"\");                     // false\r\n * isUndefined(_dummyFunction);         // false\r\n * isUndefined([]);                     // false\r\n * isUndefined(new Array(1));           // false\r\n * isUndefined(true);                   // false\r\n * isUndefined(false);                  // false\r\n * isUndefined(\"true\");                 // false\r\n * isUndefined(\"false\");                // false\r\n * isUndefined(new Boolean(true));      // false\r\n * isUndefined(new Boolean(false));     // false\r\n * isUndefined(new Boolean(\"true\"));    // false\r\n * isUndefined(new Boolean(\"false\"));   // false\r\n * isUndefined(Boolean(true));          // false\r\n * isUndefined(Boolean(false));         // false\r\n * isUndefined(Boolean(\"true\"));        // false\r\n * isUndefined(Boolean(\"false\"));       // false\r\n * isUndefined(new RegExp(\"\"));         // false\r\n * isUndefined(new ArrayBuffer(0));     // false\r\n * isUndefined(new Error(\"Test Error\"));// false\r\n * isUndefined(new TypeError(\"Test TypeError\"));    // false\r\n * isUndefined(new TestError(\"Test TestError\"));    // false\r\n * isUndefined(_dummyError());          // false\r\n * isUndefined(Promise.reject());       // false\r\n * isUndefined(Promise.resolve());      // false\r\n * isUndefined(new Promise(() => {}));  // false\r\n * isUndefined(_simplePromise());       // false\r\n * isUndefined(_simplePromiseLike());   // false\r\n * isUndefined(Object.create(null));    // false\r\n * isUndefined(polyObjCreate(null));    // false\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isUndefined(value: any) {\r\n    return typeof value === UNDEFINED || value === UNDEFINED;\r\n}\r\n\r\n/**\r\n * Checks if the provided value is undefined, a string value of \"undefined\" is NOT considered\r\n * to be undefined.\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param arg - The value to check\r\n * @returns true if the typeof value === UNDEFINED\r\n * @example\r\n * ```ts\r\n * isStrictUndefined(undefined);    // true\r\n *\r\n * isStrictUndefined(null);         // false\r\n * isStrictUndefined(\"null\");       // false\r\n * isStrictUndefined(\"undefined\");  // false\r\n * isStrictUndefined(\"1\");          // false\r\n * isStrictUndefined(\"aa\");         // false\r\n * isStrictUndefined(new Date());   // false\r\n * isStrictUndefined(0);            // false\r\n * isStrictUndefined(1);            // false\r\n * isStrictUndefined(\"\");           // false\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isStrictUndefined(arg: any): arg is undefined {\r\n    return !isDefined(arg);\r\n}\r\n\r\n/**\r\n * Checks if the provided value is null, undefined or contains the string value of \"undefined\".\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param value - The value to check\r\n * @returns `true` if the value is `null` or `undefined`\r\n * @example\r\n * ```ts\r\n * isNullOrUndefined(null);         // true\r\n * isNullOrUndefined(undefined);    // true\r\n * isNullOrUndefined(\"undefined\");  // true\r\n *\r\n * let value = null;\r\n * isNullOrUndefined(value);        // true\r\n * let value = undefined;\r\n * isNullOrUndefined(value);        // true\r\n *\r\n * isNullOrUndefined(\"\");           // false\r\n * isNullOrUndefined(0);            // false\r\n * isNullOrUndefined(new Date());   // false\r\n * isNullOrUndefined(true);         // false\r\n * isNullOrUndefined(false);        // false\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isNullOrUndefined(value:  any): boolean {\r\n    return value === NULL_VALUE || isUndefined(value);\r\n}\r\n\r\n/**\r\n * Checks if the provided value is null, undefined only, a string value of \"undefined\" is NOT considered\r\n * to be undefined.\r\n * @group Type Identity\r\n * @group Value Check\r\n * @param value - The value to check\r\n * @returns\r\n * @example\r\n * ```ts\r\n * isStrictNullOrUndefined(null);         // true\r\n * isStrictNullOrUndefined(undefined);    // true\r\n * isStrictNullOrUndefined(\"undefined\");  // false\r\n *\r\n * let value = null;\r\n * isStrictNullOrUndefined(value);        // true\r\n * let value = undefined;\r\n * isStrictNullOrUndefined(value);        // true\r\n *\r\n * isStrictNullOrUndefined(\"\");           // false\r\n * isStrictNullOrUndefined(0);            // false\r\n * isStrictNullOrUndefined(new Date());   // false\r\n * isStrictNullOrUndefined(true);         // false\r\n * isStrictNullOrUndefined(false);        // false\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isStrictNullOrUndefined(value: any): boolean {\r\n    return value === NULL_VALUE || !isDefined(value);\r\n}\r\n\r\n/**\r\n * Checks if the passed value is defined, which means it has any value and is not undefined.\r\n * A string value of \"undefined\" is considered to be defined.\r\n * @group Value Check\r\n * @param arg - The value to check\r\n * @returns true if arg has a value (is not === undefined)\r\n * @example\r\n * ```ts\r\n * isDefined(null);         // false\r\n * isDefined(undefined);    // false\r\n * isDefined(\"undefined\");  // true\r\n *\r\n * let value = null;\r\n * isDefined(value);        // false\r\n * let value = undefined;\r\n * isDefined(value);        // false\r\n *\r\n * isDefined(\"\");           // true\r\n * isDefined(0);            // true\r\n * isDefined(new Date());   // true\r\n * isDefined(true);         // true\r\n * isDefined(false);        // true\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isDefined(arg: any): boolean {\r\n    return !!arg || arg !== UNDEF_VALUE;\r\n}\r\n\r\n/**\r\n * Identifies whether the provided value is a JavaScript [primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\r\n * which is when is it not an object and has no methods or properties. There are 7 primitive data types:\r\n * - string\r\n * - number\r\n * - bigint\r\n * - boolean\r\n * - undefined\r\n * - null\r\n * - symbol\r\n *\r\n * Most of the time, a primitive value is represented directly at the lowest level of the language implementation.\r\n *\r\n * All primitives are immutable; that is, they cannot be altered. It is important not to confuse a primitive itself\r\n * with a variable assigned a primitive value. The variable may be reassigned to a new value, but the existing value\r\n * can not be changed in the ways that objects, arrays, and functions can be altered. The language does not offer\r\n * utilities to mutate primitive values.\r\n * @since 0.4.4\r\n * @group Type Identity\r\n * @param value - The value to check whether it's a primitive value\r\n * @example\r\n * ```ts\r\n * isPrimitive(null);                   // true\r\n * isPrimitive(undefined);              // true\r\n * isPrimitive(\"null\");                 // true\r\n * isPrimitive(\"undefined\");            // true\r\n * isPrimitive(\"1\");                    // true\r\n * isPrimitive(\"aa\");                   // true\r\n * isPrimitive(1);                      // true\r\n * isPrimitive(Number(2));              // true\r\n * isPrimitive(\"\");                     // true\r\n * isPrimitive(String(\"\"));             // true\r\n * isPrimitive(true);                   // true\r\n * isPrimitive(false);                  // true\r\n * isPrimitive(\"true\");                 // true\r\n * isPrimitive(\"false\");                // true\r\n * isPrimitive(BigInt(42));             // true\r\n * isPrimitive(Symbol.for(\"Hello\"));    // true\r\n *\r\n * isPrimitive(new String(\"aa\"));       // false\r\n * isPrimitive(new Date());             // false\r\n * isPrimitive(_dummyFunction);         // false\r\n * isPrimitive([]);                     // false\r\n * isPrimitive(new Array(1));           // false\r\n * isPrimitive(new Boolean(true));      // false\r\n * isPrimitive(new Boolean(false));     // false\r\n * isPrimitive(new Boolean(\"true\"));    // false\r\n * isPrimitive(new Boolean(\"false\"));   // false\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isPrimitive(value: any): value is string | number | bigint | boolean | undefined | symbol | null {\r\n    return value === NULL_VALUE || isPrimitiveType(typeof value);\r\n}\r\n\r\n/**\r\n * Identifies whether the provided value is a JavaScript [primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\r\n * which is when is it not an object and has no methods or properties. There are 6 primitive data types:\r\n * - string\r\n * - number\r\n * - bigint\r\n * - boolean\r\n * - undefined\r\n * - symbol\r\n *\r\n * Most of the time, a primitive value is represented directly at the lowest level of the language implementation.\r\n *\r\n * All primitives are immutable; that is, they cannot be altered. It is important not to confuse a primitive itself\r\n * with a variable assigned a primitive value. The variable may be reassigned to a new value, but the existing value\r\n * can not be changed in the ways that objects, arrays, and functions can be altered. The language does not offer\r\n * utilities to mutate primitive values.\r\n * @since 0.9.6\r\n * @group Type Identity\r\n * @param theType - The type as a string value to be checked whther it's a primitive type, this should be the value\r\n * returned from `typeof value`.\r\n * @example\r\n * ```ts\r\n * isPrimitiveType(null);                   // false\r\n * isPrimitiveType(undefined);              // false\r\n * isPrimitiveType(\"null\");                 // false\r\n * isPrimitiveType(\"undefined\");            // false\r\n * isPrimitiveType(\"1\");                    // false\r\n * isPrimitiveType(\"aa\");                   // false\r\n * isPrimitiveType(1);                      // false\r\n * isPrimitiveType(Number(2));              // false\r\n * isPrimitiveType(\"\");                     // false\r\n * isPrimitiveType(String(\"\"));             // false\r\n * isPrimitiveType(true);                   // false\r\n * isPrimitiveType(false);                  // false\r\n * isPrimitiveType(\"true\");                 // false\r\n * isPrimitiveType(\"false\");                // false\r\n * isPrimitiveType(BigInt(42));             // false\r\n * isPrimitiveType(Symbol.for(\"Hello\"));    // false\r\n *\r\n * isPrimitiveType(\"string\");               // true\r\n * isPrimitiveType(\"number\");               // true\r\n * isPrimitiveType(\"boolean\");              // true\r\n * isPrimitiveType(\"undefined\");            // true\r\n * isPrimitiveType(\"symbol\");               // true\r\n * isPrimitiveType(\"bigint\");               // true\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isPrimitiveType(theType: string): boolean {\r\n    !_primitiveTypes && (_primitiveTypes = [ \"string\", \"number\", \"boolean\", UNDEFINED, \"symbol\", \"bigint\" ]);\r\n\r\n    return !!(theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1);\r\n}\r\n\r\n/**\r\n * Checks to see if the past value is a string value\r\n * @group Type Identity\r\n * @group String\r\n * @param value - The value to check\r\n * @returns\r\n * @example\r\n * ```ts\r\n * isString(\"\");            // true\r\n * isString(\"null\");        // true\r\n * isString(\"undefined\");   // true\r\n * isString(String(\"\"));    // true\r\n *\r\n * isString(null);          // false\r\n * isString(undefined);     // false\r\n * isString(0);             // false\r\n * ```\r\n */\r\nexport const isString: (value: any) => value is string = (/*#__PURE__*/_createIs<string>(\"string\"));\r\n\r\n/**\r\n * Checks to see if the past value is a function value\r\n * @group Type Identity\r\n * @param value - The value to check\r\n * @returns\r\n * @example\r\n * ```ts\r\n * function myFunction() { }\r\n * isFunction(null);            // false\r\n * isFunction(undefined);       // false\r\n * isFunction(\"null\");          // false\r\n * isFunction(\"undefined\");     // false\r\n * isFunction(\"1\");             // false\r\n * isFunction(\"aa\");            // false\r\n * isFunction(new Date());      // false\r\n * isFunction(1);               // false\r\n * isFunction(\"\");              // false\r\n * isFunction(myFunction);      // true\r\n * isFunction([]);              // false\r\n * isFunction(new Array(1));    // false\r\n * ```\r\n */\r\nexport const isFunction: (value: any) => value is Function = (/*#__PURE__*/_createIs<Function>(FUNCTION));\r\n\r\n/**\r\n * Checks to see if the past value is an object value\r\n * @group Type Identity\r\n * @group Object\r\n * @typeParam T - The object type, defaults to any\r\n * @param value - The value to check\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isObject<T>(value: T): value is T {\r\n    if (!value && isNullOrUndefined(value)) {\r\n        return false;\r\n    }\r\n\r\n    return !!value && typeof value === OBJECT;\r\n}\r\n\r\n/**\r\n * Checks if the type of value is an Array.\r\n *\r\n * @group Type Identity\r\n * @group Array\r\n * @param arg - Value to be checked.\r\n * @return True if the value is a Array, false otherwise.\r\n * @example\r\n * ```ts\r\n * import { isArray, isObject } from \"@nevware21/ts-utils\";\r\n *\r\n * function performAction(value: any) {\r\n *     if (isArray(value) || isObject(value)) {\r\n *         // Do something\r\n *     } else {\r\n *         // Do something else\r\n *     }\r\n * }\r\n * ```\r\n */\r\nexport const isArray: <T = any>(arg: any) => arg is Array<T> = (/* #__PURE__*/_pureRef<typeof ArrCls.isArray>(ArrCls as any, \"isArray\"));\r\n\r\n/**\r\n * Check if an object is of type Date\r\n * @group Type Identity\r\n * @example\r\n * ```ts\r\n * import { isDate } from \"@nevware21/ts-utils\";\r\n *\r\n * let _theDate = null;\r\n *\r\n * function getSetDate(newDate?: any) {\r\n *     _theDate = isDate(newDate) ? newDate : new Date();\r\n *\r\n *     return _theDate;\r\n * }\r\n * ```\r\n */\r\nexport const isDate: (value: any) => value is Date = (/*#__PURE__*/_createObjIs<Date>(\"Date\"));\r\n\r\n/**\r\n * Checks if the type of value is a number.\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a number, false otherwise.\r\n */\r\nexport const isNumber: (value: any) => value is number = (/*#__PURE__*/_createIs<number>(\"number\"));\r\n\r\n/**\r\n * Checks if the type of value is a boolean.\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a boolean, false otherwise.\r\n */\r\nexport const isBoolean: (value: any) => value is boolean = (/*#__PURE__*/_createIs<boolean>(\"boolean\"));\r\n\r\n/**\r\n * Determines if a value is a regular expression object.\r\n * @group Type Identity\r\n * @param value - Reference to check.\r\n * @returns True if `value` is a `RegExp`.\r\n */\r\nexport const isRegExp: (value: any) => value is RegExp = (/*#__PURE__*/_createObjIs<RegExp>(\"RegExp\"));\r\n\r\n/**\r\n * Checks if the type of value is a File object.\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a File, false otherwise.\r\n */\r\nexport const isFile: (value: any) => value is File = (/*#__PURE__*/_createObjIs<File>(\"File\"));\r\n\r\n/**\r\n * Checks if the type of value is a FormData object.\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a FormData, false otherwise.\r\n */\r\nexport const isFormData: (value: any) => value is FormData = (/*#__PURE__*/_createObjIs<FormData>(\"FormData\"));\r\n\r\n/**\r\n * Checks if the type of value is a Blob object.\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a Blob, false otherwise.\r\n */\r\nexport const isBlob: (value: any) => value is Blob = (/*#__PURE__*/_createObjIs<Blob>(\"Blob\"));\r\n\r\n/**\r\n * Checks if the type of value is a ArrayBuffer object.\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a ArrayBuffer, false otherwise.\r\n */\r\nexport const isArrayBuffer: (value: any) => value is ArrayBuffer = (/*#__PURE__*/_createObjIs<ArrayBuffer>(\"ArrayBuffer\"));\r\n\r\n/**\r\n * Checks if the type of value is a Error object.\r\n * @group Type Identity\r\n * @group Error\r\n * @param value - Value to be checked.\r\n * @return True if the value is a Error, false otherwise.\r\n */\r\nexport const isError: (value: any) => value is Error = (/*#__PURE__*/_createObjIs<Error>(\"Error\"));\r\n\r\n/**\r\n * Checks if the type of value is a PromiseLike instance (contains a then function).\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a PromiseLike, false otherwise.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isPromiseLike<T>(value: any): value is PromiseLike<T> {\r\n    return !!(value && value.then && isFunction(value.then));\r\n}\r\n\r\n/**\r\n * Checks if the type of value is a PromiseLike instance (contains a then function).\r\n * This is an alias for {@link isPromiseLike}.\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a PromiseLike, false otherwise.\r\n */\r\nexport const isThenable: <T>(value: any) => value is PromiseLike<T> = isPromiseLike;\r\n\r\n/**\r\n * Checks if the type of value is a Promise instance (contains then and catch functions).\r\n * @group Type Identity\r\n * @param value - Value to be checked.\r\n * @return True if the value is a Promise, false otherwise.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isPromise<T>(value: any): value is Promise<T> {\r\n    return !!(value && value.then && value.catch && isFunction(value.then) && isFunction((value as any).catch));\r\n}\r\n\r\n/**\r\n * Checks if the type of value does not evaluate to true value, handling some special\r\n * case usages of Boolean(true/false) and new Boolean(true/false).\r\n * @group Value Check\r\n * @param value - Value to be checked.\r\n * @return True if the value is not truthy, false otherwise.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isNotTruthy(value: any) {\r\n    return !value || !isTruthy(value);\r\n}\r\n\r\n/**\r\n * Checks if the type of value evaluates to true value, handling some special\r\n * case usages of Boolean(true/false) and new Boolean(true/false).\r\n * @group Value Check\r\n * @param value - Value to be checked.\r\n * @return True if the value is not truthy, false otherwise.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isTruthy(value: any) {\r\n    // Objects created with no prototype (Object.create(null)) cannot be converted to primitives\r\n    // Which causes this code to throw, additionally just using !! also fails for Boolean objects\r\n    // !!(new Boolean(false)) evaluates to true\r\n    return !(!value || safeGet(() => !(value && (0 + value)), !value));\r\n    //return !(!value || !(value && (0 + value)));\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ObjClass } from \"../internal/constants\";\r\nimport { _pureAssign, _pureRef } from \"../internal/treeshake_helpers\";\r\nimport { objGetOwnPropertyDescriptor } from \"./get_own_prop_desc\";\r\nimport { objHasOwnProperty } from \"./has_own_prop\";\r\n\r\n/**\r\n * The objHasOwn() method returns a boolean indicating whether the object\r\n * has the specified property as its own property (as opposed to inheriting it).\r\n * If the property is inherited, or does not exist, the method returns false.\r\n *\r\n * The objHasOwn() method returns true if the specified property is a direct property\r\n * of the object — even if the property value is null or undefined. The method returns\r\n * false if the property is inherited, or has not been declared at all. Unlike the in operator,\r\n * this method does not check for the specified property in the object's prototype chain.\r\n *\r\n * It is recommended over {@link objHasOwnProperty} () because it works for objects created using\r\n * objCreate(null) and with objects that have overridden the inherited hasOwnProperty() method.\r\n * While it is possible to workaround these problems by calling Object.prototype.hasOwnProperty()\r\n * on an external object, Object.hasOwn() is more intuitive.\r\n *\r\n * @since 0.4.3\r\n * @group Object\r\n * @param obj - The object being evaluated\r\n * @param prop - The String or Symbol of the property to test\r\n * @returns `true` if the object has the specified property as own property; otherwise `false`\r\n * @example\r\n * ```ts\r\n * let example = {};\r\n * objHasOwn(example, 'prop');   // false\r\n *\r\n * example.prop = 'exists';\r\n * objHasOwn(example, 'prop');   // true - 'prop' has been defined\r\n *\r\n * example.prop = null;\r\n * objHasOwn(example, 'prop');   // true - own property exists with value of null\r\n *\r\n * example.prop = undefined;\r\n * objHasOwn(example, 'prop');   // true - own property exists with value of undefined\r\n * ```\r\n */\r\nexport const objHasOwn: <T = any>(obj: T, prop: PropertyKey) => boolean = (/*#__PURE__*/_pureAssign((/* #__PURE__ */_pureRef(ObjClass as any, \"hasOwn\")), polyObjHasOwn));\r\n\r\n/**\r\n * The polyObjHasOwn() method is a polyfill for {@link objHasOwn} when the native\r\n * [Object.hasOwnreturns](https://caniuse.com/?search=hasOwn) is not supported, it returns a\r\n * boolean indicating whether the object has the specified property as its own property (as\r\n * opposed to inheriting it). If the property is inherited, or does not exist, the method\r\n * returns false.\r\n *\r\n * The objHasOwn() method returns true if the specified property is a direct property\r\n * of the object — even if the property value is null or undefined. The method returns\r\n * false if the property is inherited, or has not been declared at all. Unlike the in operator,\r\n * this method does not check for the specified property in the object's prototype chain.\r\n *\r\n * It is recommended over objHasOwnProperty() because it works for objects created using\r\n * objCreate(null) and with objects that have overridden the inherited hasOwnProperty() method.\r\n * While it is possible to workaround these problems by calling Object.prototype.hasOwnProperty()\r\n * on an external object, Object.hasOwn() is more intuitive.\r\n *\r\n * @since 0.4.3\r\n * @group Object\r\n * @group Polyfill\r\n * @param obj - The object being evaluated\r\n * @param prop - The String or Symbol of the property to test\r\n * @returns `true` if the object has the specified property as own property; otherwise `false`\r\n * @example\r\n * ```ts\r\n * let example = {};\r\n * polyObjHasOwn(example, 'prop');   // false\r\n *\r\n * example.prop = 'exists';\r\n * polyObjHasOwn(example, 'prop');   // true - 'prop' has been defined\r\n *\r\n * example.prop = null;\r\n * polyObjHasOwn(example, 'prop');   // true - own property exists with value of null\r\n *\r\n * example.prop = undefined;\r\n * polyObjHasOwn(example, 'prop');   // true - own property exists with value of undefined\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyObjHasOwn<T = any>(obj: T, prop: PropertyKey): boolean {\r\n    return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop)\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { CALL, ObjProto } from \"../internal/constants\";\r\n\r\n/**\r\n * The objHasOwnProperty() method returns a boolean indicating whether the object\r\n * has the specified property as its own property (as opposed to inheriting it).\r\n *\r\n * The objHasOwnProperty() method returns true if the specified property is a direct\r\n * property of the object — even if the value is null or undefined. The method returns\r\n * false if the property is inherited, or has not been declared at all. Unlike the in\r\n * operator, this method does not check for the specified property in the object's\r\n * prototype chain.\r\n *\r\n * The method can be called on most JavaScript objects, because most objects descend\r\n * from Object, and hence inherit its methods. For example Array is an Object, so you\r\n * can use objHasOwnProperty() method to check whether an index exists:\r\n * @group Object\r\n * @param obj - The object being evaluated\r\n * @param prop - The String or Symbol of the property to test\r\n * @returns `true` if the object has the specified property as own property; otherwise `false`\r\n * @example\r\n * ```ts\r\n * let example = {};\r\n * objHasOwnProperty(example, 'prop');   // false\r\n *\r\n * example.prop = 'exists';\r\n * objHasOwnProperty(example, 'prop');   // true - 'prop' has been defined\r\n *\r\n * example.prop = null;\r\n * objHasOwnProperty(example, 'prop');   // true - own property exists with value of null\r\n *\r\n * example.prop = undefined;\r\n * objHasOwnProperty(example, 'prop');   // true - own property exists with value of undefined\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function objHasOwnProperty<T = any>(obj: T, prop: PropertyKey): boolean {\r\n    return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isObject } from \"../helpers/base\";\r\nimport { CALL } from \"../internal/constants\";\r\nimport { objHasOwn } from \"./has_own\";\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each key in an object. This is equivelent to `arrForEach(Object.keys(theObject), callbackFn)` or\r\n * if not using the array helper `Object.keys(theObject).forEach(callbackFn)` except that this helper avoid creating a temporary of the object\r\n * keys before iterating over them and like the `arrForEach` helper you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n * @group Object\r\n * @typeParam T - The object type\r\n * @param callbackfn - A function that accepts up to two arguments, the key name and the current value of the property represented by the key.\r\n * @param thisArg - [Optional] An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the object will be used as the this value.\r\n * @example\r\n * ```ts\r\n * function performAction<T>(target: T, source: any) {\r\n *    if (!isNullOrUndefined(source)) {\r\n *        objForEachKey(source, (key, value) => {\r\n *            // Set the target with a reference to the same value with the same name\r\n *            target[key] = value;\r\n *        });\r\n *    }\r\n *\r\n *    return target;\r\n * }\r\n * ```\r\n */\r\nexport function objForEachKey<T>(theObject: T, callbackfn: (key: string, value: T[keyof T]) => void | number, thisArg?: any): void {\r\n    if (theObject && isObject(theObject)) {\r\n        for (const prop in theObject) {\r\n            if (objHasOwn(theObject, prop)) {\r\n                if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ObjClass } from \"../internal/constants\";\r\nimport { isFunction, isStrictUndefined } from \"../helpers/base\";\r\nimport { objForEachKey } from \"./for_each_key\";\r\nimport { ILazyValue } from \"../helpers/lazy\";\r\nimport { objGetOwnPropertyDescriptor } from \"./get_own_prop_desc\";\r\nimport { _pureRef } from \"../internal/treeshake_helpers\";\r\n\r\n/**\r\n * Definition of the Property Descriptor mappings for the objDefine functions.\r\n * If a descriptor has neither of value, writable, get and set keys, it is treated as a data descriptor.\r\n * If a descriptor has both [value or writable] and [get or set] keys, an exception is thrown.\r\n * Bear in mind that these attributes are not necessarily the descriptor's own properties. Inherited\r\n * properties will be considered as well. In order to ensure these defaults are preserved, you might\r\n * freeze existing objects in the descriptor object's prototype chain upfront, specify all options\r\n * explicitly, or point to null with {@link objCreate}(null).\r\n * @since 0.6.0\r\n * @group Object\r\n */\r\nexport interface ObjDefinePropDescriptor<V = any> {\r\n    /**\r\n     * Identifies if this property should be configurable (true) when this value is set to false,\r\n     * - the type of this property cannot be changed between data property and accessor property, and\r\n     * - the property may not be deleted, and\r\n     * - other attributes of its descriptor cannot be changed (however, if it's a data descriptor with writable: true,\r\n     * the value can be changed, and writable can be changed to false).\r\n     * Defaults to true.\r\n     */\r\n    c?: boolean;\r\n\r\n    /**\r\n     * Identifies if this property will be visible during enumeration of the properties on the corresponding object.\r\n     * Defaults to true.\r\n     */\r\n    e?: boolean;\r\n\r\n    /**\r\n     * __data descriptor__\r\n     * The value associated with the property. Can be any valid JavaScript value (number, object, function, etc.).\r\n     * Defaults to undefined.\r\n     */\r\n    v?: V;\r\n\r\n    /**\r\n     * A Lazy value instance which will be used to return the value, this will be wrapped in a getter function.\r\n     * @since 0.9.4\r\n     */\r\n    l?: ILazyValue<V>;\r\n\r\n    /**\r\n     * true if the value associated with the property may be changed with an assignment operator. Defaults to false.\r\n     */\r\n    w?: boolean;\r\n\r\n    /**\r\n     * A function which serves as a getter for the property, or undefined if there is no getter. When the property\r\n     * is accessed, this function is called without arguments and with this set to the object through which the\r\n     * property is accessed (this may not be the object on which the property is defined due to inheritance). The\r\n     * return value will be used as the value of the property. Defaults to undefined.\r\n     */\r\n    g?(): V;\r\n\r\n    /**\r\n     * A function which serves as a setter for the property, or undefined if there is no setter. When the property\r\n     * is assigned, this function is called with one argument (the value being assigned to the property) and with\r\n     * this set to the object through which the property is assigned. Defaults to undefined.\r\n     * @param value - The value to set the property to.\r\n     */\r\n    s?(value: V): void;\r\n}\r\n\r\n/**\r\n * An object whose keys represent the names of properties to be defined or modified and whose values are objects\r\n * describing those properties. Each value in props must be either a data descriptor or an accessor descriptor;\r\n * it cannot be both (see {@link ObjDefinePropDescriptor} for more details).\r\n * @since 0.6.0\r\n * @group Object\r\n */\r\nexport type ObjDefinePropDescriptorMap = {\r\n    [key: PropertyKey]: ObjDefinePropDescriptor\r\n};\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Mapping from ObjDefinePropDescriptor key to PropertyDescriptor key\r\n */\r\nconst propMap: { [key in keyof ObjDefinePropDescriptor]: keyof PropertyDescriptor } = {\r\n    e: \"enumerable\",\r\n    c: \"configurable\",\r\n    v: \"value\",\r\n    w: \"writable\",\r\n    g: \"get\",\r\n    s: \"set\"\r\n};\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper to convert ObjDefinePropDescriptor into PropertyDescriptor\r\n * @param value - The prop descriptor to convert\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createProp(value: ObjDefinePropDescriptor): PropertyDescriptor {\r\n    let prop: PropertyDescriptor = {};\r\n    prop[propMap[\"c\"]] = true;\r\n    prop[propMap[\"e\"]] = true;\r\n\r\n    if (value.l) {\r\n        // Asign a getter function to return the value when requested\r\n        prop.get = () => value.l.v;\r\n\r\n        // If it has a setter then expose it as well\r\n        let desc = objGetOwnPropertyDescriptor(value.l, \"v\");\r\n        if (desc && desc.set) {\r\n            prop.set = (newValue: any) => {\r\n                value.l.v = newValue;\r\n            };\r\n        }\r\n    }\r\n\r\n    objForEachKey(value, (key: keyof ObjDefinePropDescriptor, value) => {\r\n        prop[propMap[key]] = isStrictUndefined(value) ? prop[propMap[key]] : value;\r\n    });\r\n\r\n    return prop;\r\n}\r\n\r\n/**\r\n * Defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\r\n * This is a wrapper for [Object.defineProperty](https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/object/defineproperty)\r\n *\r\n * This method allows a precise addition to or modification of a property on an object. Normal property addition through\r\n * assignment creates properties which show up during property enumeration (for...in loop or objKeys method), whose\r\n * values may be changed, and which may be deleted. This method allows these extra details to be changed from their\r\n * defaults. By default, properties added using objDefineProp() are not writable, not enumerable, and not configurable.\r\n *\r\n * Property descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data\r\n * descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property\r\n * described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\r\n *\r\n * This is an alias for Object.defineProperty\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param key - The name or Symbol of the property to be defined or modified.\r\n * @param descriptor - The descriptor for the property being defined or modified.\r\n * @returns The object that was passed to the function with the new or updated property.\r\n */\r\nexport const objDefineProp: <T>(target: T, key: PropertyKey, descriptor: PropertyDescriptor & ThisType<any>) => T = (/*#__PURE__*/_pureRef<typeof Object.defineProperty>(ObjClass as any, \"defineProperty\"));\r\n\r\n/**\r\n * The objDefineProperties() method defines new or modifies existing properties directly on an object, returning the object.\r\n * This is a wrapper for [Object.defineProperties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)\r\n * @since 0.6.0\r\n * @group Object\r\n * @param target - The object on which to define or modify properties.\r\n * @param props - An object whose keys represent the names of properties to be defined or modified and whose values are\r\n * objects describing those properties. Each value in props must be either a data descriptor or an accessor descriptor;\r\n * it cannot be both (see {@link ObjDefinePropDescriptorMap} for more details).\r\n * @returns\r\n */\r\nexport const objDefineProperties: <T>(target: T, props: PropertyDescriptorMap & ThisType<any>) => T = (/*#__PURE__*/_pureRef<typeof Object.defineProperties>(ObjClass as any, \"defineProperties\"));\r\n\r\n/**\r\n * Try to define a get object property accessor for the target object, if a function is past as the value this will\r\n * be assumed to be a getter function and NOT the value.\r\n * @deprecated It is recommended that you use {@link objDefine} instead {@link objDefineGet} or {@link objDefineAccessors}\r\n * as it provides a deterministic way for identifying whether the value is a value or a function rather than wrapping any\r\n * function value in another function.\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param key - The name of the property to be defined or modified\r\n * @param value - The value or a function that returns the value\r\n * @param configurable - Can the value be changed, defaults to true.\r\n * @param enumerable - Should this get property be enumerable, defaults to true.\r\n * @returns The object that was passed to the function\r\n */\r\nexport function objDefineGet<T, V = any>(target: T, key: PropertyKey, value: (() => V) | V, configurable?: boolean, enumerable?: boolean): T {\r\n    return objDefineProp(target, key, _createProp({\r\n        e: enumerable,\r\n        c: configurable,\r\n        [isFunction(value) ? \"g\" : \"v\"]: value\r\n    }));\r\n}\r\n\r\n/**\r\n * Try to define get/set object property accessors for the target object/prototype, this will provide compatibility with\r\n * existing API definition when run within an ES5+ container that supports accessors but still enable the code to be loaded\r\n * and executed in an ES3 container, providing basic IE8 compatibility.\r\n * @deprecated It is recommended that you use {@link objDefine} instead {@link objDefineAccessors} as this internally creates\r\n * the {@link ObjDefinePropDescriptor} definition based on your provided arguments. And only using a minimum set of functions\r\n * reduces your overall bundle size.\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param prop - The name of the property to be defined or modified.\r\n * @param getProp - The getter function to wire against the getter.\r\n * @param setProp - The setter function to wire against the setter.\r\n * @param configurable - Can the value be changed, defaults to true\r\n * @param enumerable - Should this get property be enumerable, defaults to true.\r\n * @returns The object that was passed to the function\r\n */\r\nexport function objDefineAccessors<T, V = any>(target: T, prop: PropertyKey, getProp?: (() => V) | null, setProp?: ((v: V) => void) | null, configurable?: boolean, enumerable?: boolean): T {\r\n    let desc: ObjDefinePropDescriptor = {\r\n        e: enumerable,\r\n        c: configurable\r\n    };\r\n\r\n    if (getProp) {\r\n        desc.g = getProp;\r\n    }\r\n\r\n    if (setProp) {\r\n        desc.s = setProp;\r\n    }\r\n    \r\n    return objDefineProp(target, prop, _createProp(desc));\r\n}\r\n\r\n/**\r\n * The objDefine() method defines a new or modifies an existing single property accessors for the target object based\r\n * on the configuration defined for the propDesc argument of type {@link ObjDefinePropDescriptor}. This will call\r\n * {@link objDefineProp} after creating the required PropertyDescriptor populating defaults for the propDesc values.\r\n * Note, the default values (true) for `configurable` and `enumerable` are different from the defaults provided by objDefineProp.\r\n * @since 0.6.0\r\n * @group Object\r\n * @param target - The object on which to define the property.\r\n * @param key - The name of the property to be defined or modified\r\n * @param propDesc - An object which defines the Property Descriptor mappings for the mapping.\r\n * @returns The target object.\r\n */\r\nexport function objDefine<T>(target: T, key: keyof T, propDesc: ObjDefinePropDescriptor): T {\r\n    return objDefineProp(target, key, _createProp(propDesc));\r\n}\r\n\r\n/**\r\n * The objDefineProps() method defines new or modifies existing properties directly for the target object using the keys\r\n * and configuration from the propDescMap argument. This will call {@link objDefineProperties} after creating the required\r\n * PropertyDescriptorMap from the propDescMap values.\r\n * Note, the default values (true) for `configurable` and `enumerable` are different from the defaults provided by objDefineProperties.\r\n * @since 0.6.0\r\n * @group Object\r\n * @param target - The object on which to define or modify properties.\r\n * @param propDescMap - An object whose keys represent the names of properties to be defined or modified and whose values are\r\n * objects describing those properties. Each value in props must be either a data descriptor or an accessor descriptor;\r\n * it cannot be both (see {@link ObjDefinePropDescriptorMap} for more details).\r\n * @returns The target object.\r\n */\r\nexport function objDefineProps<T>(target: T, propDescMap: ObjDefinePropDescriptorMap) {\r\n    let props: PropertyDescriptorMap = {};\r\n\r\n    objForEachKey(propDescMap, (key, value: ObjDefinePropDescriptor) => {\r\n        props[key] = _createProp(value);\r\n    });\r\n\r\n    return objDefineProperties(target, props);\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { objDefineProp } from \"../object/define\";\r\nimport { objForEachKey } from \"../object/for_each_key\";\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal constant enum used to identify the mapping values for the _createMap function\r\n */\r\nexport const enum eMapValues {\r\n    Key = 0,\r\n    Value = 1\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal Helper function to create a key and value mapped representation of the values\r\n * @param values - The source values\r\n * @param keyType - Identifies the value to populate against the key\r\n * @param valueType - Identifies the value to populate against the value\r\n * @param completeFn - The function to call to complete the map (used to freeze the instance)\r\n * @param writable - Flag to indicate if the map should be writable\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createKeyValueMap(values: any, keyType: eMapValues, valueType: eMapValues, completeFn?: <T>(value: T) => T, writable?: boolean) {\r\n    let theMap: any = {};\r\n    objForEachKey(values, (key, value) => {\r\n        _assignMapValue(theMap, key, keyType ? value : key, writable);\r\n        _assignMapValue(theMap, value, valueType ? value : key, writable);\r\n    });\r\n\r\n    return completeFn ? completeFn(theMap) : theMap;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal Helper function to assign a key and value to the map\r\n * @param theMap - The map to assign the key and value to\r\n * @param key - The key to assign\r\n * @param value - The value to assign\r\n * @param writable - Flag to indicate if the map should be writable\r\n */\r\nexport function _assignMapValue(theMap: any, key: any, value: any, writable?: boolean) {\r\n    objDefineProp(theMap, key, {\r\n        value: value,\r\n        enumerable: true,\r\n        writable: !!writable\r\n    });\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { CALL, EMPTY, NULL_VALUE, ObjProto, TO_STRING, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { asString } from \"../string/as_string\";\r\n\r\nconst ERROR_TYPE = \"[object Error]\";\r\n\r\n/**\r\n * Returns string representation of an object suitable for diagnostics logging.\r\n * @group Error\r\n * @group Diagnostic\r\n * @param object - The object to be converted to a diagnostic string value\r\n * @param format - Identifies whether the JSON value should be formated\r\n * - `true` - Format with 4 spaces\r\n * - 'number' - The number of spaces to format with\r\n * - `false` (or not Truthy) - Do not format\r\n * @returns A string representation of the object suitable for diagnostics logging\r\n * @example\r\n * ```ts\r\n * let obj = { a: 1, b: \"Hello\", c: { d: 2, e: \"Darkness\" } };\r\n *\r\n * let objStr = dumpObj(obj);\r\n * // objStr === \"[object Object]: { a: 1, b: \"Hello\", c: { d: 2, e: \"Darkness\" } }\"\r\n *\r\n * let objStrFmt = dumpObj(obj, true);\r\n * // objStrFmt === \"[object Object]: {\\n    a: 1,\\n    b: \"Hello\",\\n    c: {\\n        d: 2,\\n        e: \"Darkness\"\\n    }\\n}\"\r\n *\r\n * let objStrFmt2 = dumpObj(obj, 2);\r\n * // objStrFmt2 === \"[object Object]: {\\n  a: 1,\\n  b: \"Hello\",\\n  c: {\\n    d: 2,\\n    e: \"Darkness\"\\n  }\\n}\"\r\n *\r\n * let objStrFmt3 = dumpObj(obj, 0);\r\n * // objStrFmt3 === \"[object Object]: { a: 1, b: \"Hello\", c: { d: 2, e: \"Darkness\" } }\"\r\n *\r\n * let objStrFmt4 = dumpObj(obj, false);\r\n * // objStrFmt4 === \"[object Object]: { a: 1, b: \"Hello\", c: { d: 2, e: \"Darkness\" } }\"\r\n *\r\n * let objStrFmt5 = dumpObj(obj, null);\r\n * // objStrFmt5 === \"[object Object]: { a: 1, b: \"Hello\", c: { d: 2, e: \"Darkness\" } }\"\r\n *\r\n * let objStrFmt6 = dumpObj(obj, undefined);\r\n * // objStrFmt6 === \"[object Object]: { a: 1, b: \"Hello\", c: { d: 2, e: \"Darkness\" } }\"\r\n *\r\n * let objStrFmt7 = dumpObj(obj, \"\");\r\n * // objStrFmt7 === \"[object Object]: { a: 1, b: \"Hello\", c: { d: 2, e: \"Darkness\" } }\"\r\n *\r\n * let err = new Error(\"Hello Darkness\");\r\n * let errStr = dumpObj(err);\r\n * // errStr === \"[object Error]: { stack: 'Error: Hello Darkness\\n    at <anonymous>:1:13', message: 'Hello Darkness', name: 'Error'\"\r\n *\r\n * let errStrFmt = dumpObj(err, true);\r\n * // errStrFmt === \"[object Error]: {\\n    stack: \"Error: Hello Darkness\\n    at <anonymous>:1:13\",\\n    message: \"Hello Darkness\",\\n    name: \"Error\"\\n}\"\r\n *\r\n * let errStrFmt2 = dumpObj(err, 2);\r\n * // errStrFmt2 === \"[object Error]: {\\n  stack: \"Error: Hello Darkness\\n    at <anonymous>:1:13\",\\n  message: \"Hello Darkness\",\\n  name: \"Error\"\\n}\"\r\n *\r\n * let errStrFmt3 = dumpObj(err, 0);\r\n * // errStrFmt3 === \"[object Error]: { stack: \"Error: Hello Darkness\\n    at <anonymous>:1:13\", message: \"Hello Darkness\", name: \"Error\" }\"\r\n *\r\n * ```\r\n * @see {@link dumpObj}\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function dumpObj(object: any, format?: boolean | number): string {\r\n    let propertyValueDump = EMPTY;\r\n    const objType = ObjProto[TO_STRING][CALL](object);\r\n    if (objType === ERROR_TYPE) {\r\n        object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };\r\n    }\r\n\r\n    try {\r\n        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (((typeof format as unknown) === \"number\") ? format as number : 4) : UNDEF_VALUE);\r\n        propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/\"(\\w+)\"\\s*:\\s{0,1}/g, \"$1: \") : NULL_VALUE) || asString(object);\r\n    } catch(e) {\r\n        // Unable to convert object (probably circular)\r\n        propertyValueDump = \" - \" + dumpObj(e, format);\r\n    }\r\n\r\n    return objType + \": \" + propertyValueDump;\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/**\r\n * Throw an error exception with the specified optional message\r\n * @group Error\r\n * @param message - The optional message to include in the error\r\n */\r\nexport function throwError(message?: string): never {\r\n    throw new Error(message);\r\n}\r\n\r\n/**\r\n * Throw a type error with the specified optional message\r\n * @group Error\r\n * @param message - The optional message to include in the error\r\n */\r\nexport function throwTypeError(message?: string): never {\r\n    throw new TypeError(message);\r\n}\r\n\r\n/**\r\n * Throw a RangeError with the specified optional message\r\n * @group Error\r\n * @param message - The optional message to include in the error\r\n */\r\nexport function throwRangeError(message?: string): never {\r\n    throw new RangeError(message);\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE, ObjClass, __PROTO__ } from \"../internal/constants\";\r\nimport { isArray, isObject } from \"../helpers/base\";\r\nimport { objForEachKey } from \"./for_each_key\";\r\nimport { polyObjEntries, polyObjValues } from \"../polyfills/object\";\r\nimport { _pureAssign, _pureRef } from \"../internal/treeshake_helpers\";\r\n\r\nconst _objFreeze = (/* #__PURE__ */_pureRef<typeof Object.freeze>(ObjClass, \"freeze\"));\r\n\r\nfunction _doNothing<T>(value: T) {\r\n    return  value;\r\n}\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _getProto(value: any) {\r\n    return value[__PROTO__] || NULL_VALUE;\r\n}\r\n\r\n/**\r\n * The `objAssign()` method copies all enumerable own properties from one or more source objects\r\n * to a target object. It returns the modified target object.\r\n *\r\n * Properties in the target object are overwritten by properties in the sources if they have the\r\n * same key. Later sources' properties overwrite earlier ones.\r\n *\r\n * The objAssign() method only copies enumerable and own properties from a source object to a\r\n * target object. It uses `Get` on the source and `Set` on the target, so it will invoke\r\n * [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) and\r\n * [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\r\n * Therefore it assigns properties, versus copying or defining new properties. This may make it\r\n * unsuitable for merging new properties into a prototype if the merge sources contain getters.\r\n *\r\n * For copying property definitions (including their enumerability) into prototypes, use\r\n * {@link objGetOwnPropertyDescriptor} and {@link objDefineProp} instead.\r\n *\r\n * Both String and Symbol properties are copied.\r\n *\r\n * In case of an error, for example if a property is non-writable, a TypeError is raised, and\r\n * the target object is changed if any properties are added before the error is raised.\r\n * @group Object\r\n * @example\r\n * ```ts\r\n * const obj = { a: 1 };\r\n * const copy = objAssign({}, obj);\r\n * console.log(copy); // { a: 1 }\r\n *\r\n * const o1 = { a: 1 };\r\n * const o2 = { b: 2 };\r\n * const o3 = { c: 3 };\r\n *\r\n * const obj = objAssign(o1, o2, o3);\r\n * console.log(obj); // { a: 1, b: 2, c: 3 }\r\n * console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.\r\n * ```\r\n */\r\nexport const objAssign = (/*#__PURE__*/_pureRef<typeof Object.assign>(ObjClass, \"assign\"));\r\n\r\n/**\r\n * The `objKeys()` method returns an array of a given object's own enumerable property names, iterated in\r\n * the same order that a normal loop would.\r\n *\r\n * objKeys() returns an array whose elements are strings corresponding to the enumerable properties found\r\n * directly upon object. The ordering of the properties is the same as that given by looping over the\r\n * properties of the object manually.\r\n * @group Object\r\n * @param value - The object to obtain a copy of the keys from\r\n * @returns An array of the properties names for the value object.\r\n * @example\r\n * ```ts\r\n * // simple array\r\n * const arr = ['a', 'b', 'c'];\r\n * console.log(objKeys(arr)); // console: ['0', '1', '2']\r\n *\r\n * // array-like object\r\n * const obj = { 0: 'a', 1: 'b', 2: 'c' };\r\n * console.log(objKeys(obj)); // console: ['0', '1', '2']\r\n *\r\n * // array-like object with random key ordering\r\n * const anObj = { 100: 'a', 2: 'b', 7: 'c' };\r\n * console.log(objKeys(anObj)); // console: ['2', '7', '100']\r\n *\r\n * // getFoo is a property which isn't enumerable\r\n * const myObj = objCreate({}, {\r\n *   getFoo: {\r\n *     value() { return this.foo; }\r\n *   }\r\n * });\r\n * myObj.foo = 1;\r\n * console.log(objKeys(myObj)); // console: ['foo']\r\n * ```\r\n */\r\nexport const objKeys: (value: any) => string[] = (/*#__PURE__*/_pureRef<typeof Object.keys>(ObjClass, \"keys\"));\r\n\r\n/**\r\n * Perform a deep freeze on the object and all of it's contained values / properties by recursively calling\r\n * `objFreeze()` on all enumerable properties of the object and on each property returned.\r\n * @group Object\r\n * @param value - the object to be completly frozen.\r\n * @returns The originally passed in object.\r\n */\r\nexport function objDeepFreeze<T>(value: T): T {\r\n    if (_objFreeze) {\r\n        objForEachKey(value, (key, value) => {\r\n            if (isArray(value) || isObject(value)) {\r\n                objDeepFreeze(value);\r\n            }\r\n        });\r\n    }\r\n\r\n    return objFreeze(value);\r\n}\r\n\r\n/**\r\n * The `objFreeze()` method freezes an object. A frozen object can no longer be changed; freezing an object\r\n * prevents new properties from being added to it, existing properties from being removed, prevents changing the\r\n * enumerability, configurability, or writability of existing properties, and prevents the values of existing\r\n * properties from being changed. In addition, freezing an object also prevents its prototype from being changed.\r\n * `objFreeze()` returns the same object that was passed in.\r\n *\r\n * Nothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail,\r\n * either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\r\n *\r\n * For data properties of a frozen object, values cannot be changed, the writable and configurable attributes are\r\n * set to false. Accessor properties (getters and setters) work the same (and still give the illusion that you are\r\n * changing the value). Note that values that are objects can still be modified, unless they are also frozen. As\r\n * an object, an array can be frozen; after doing so, its elements cannot be altered and no elements can be added\r\n * to or removed from the array.\r\n *\r\n * `objFreeze()` returns the same object that was passed into the function. It does not create a frozen copy.\r\n * @group Object\r\n * @param value - The object to freeze.\r\n * @returns The object that was passed to the function.\r\n */\r\nexport const objFreeze: <T>(value: T) => T = (/* #__PURE__*/_pureAssign(_objFreeze, _doNothing));\r\n\r\n/**\r\n * The `objSeal()` method seals an object, preventing new properties from being added to it and marking all\r\n * existing properties as non-configurable. Values of present properties can still be changed as long as they\r\n * are writable.\r\n * @group Object\r\n * @param value - The object which should be sealed.\r\n * @returns The object being sealed.\r\n */\r\nexport const objSeal: <T>(value: T) => T = (/* #__PURE__*/_pureAssign((/* #__PURE__*/_pureRef<typeof Object.seal>(ObjClass, \"seal\")), _doNothing));\r\n\r\n/**\r\n * The objGetPrototypeOf() method returns the prototype (i.e. the value of the internal `Prototype` property)\r\n * of the specified value.\r\n * @since 0.4.4\r\n * @group Object\r\n * @param value - The object whose prototype is to be returned, which may be null.\r\n */\r\nexport const objGetPrototypeOf: (value: any) => any = (/* #__PURE__*/_pureAssign((/* #__PURE__*/_pureRef<typeof Object.getPrototypeOf>(ObjClass, \"getPrototypeOf\")), _getProto));\r\n\r\n/**\r\n * Returns an array of key/values of the enumerable properties of an object\r\n * @since 0.9.7\r\n * @group Object\r\n * @group ArrayLike\r\n * @param value - Object that contains the properties and methods.\r\n * @example\r\n * ```ts\r\n * objEntries({ Hello: \"Darkness\", my: \"old\", friend: \".\" });\r\n * // [ [ \"Hello\", \"Darkness\" ], [ \"my\", \"old\"], [ \"friend\", \".\" ] ]\r\n *\r\n * // Array-like object\r\n * objEntries({ 0: \"a\", 1: \"b\", 2: \"c\" }));\r\n * // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]\r\n *\r\n * // Array-like object with random key ordering\r\n * objEntries({ 100: \"a\", 2: \"b\", 7: \"c\" });\r\n * // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]*\r\n * ```\r\n */\r\nexport const objEntries: <T = any>(value: {} | { [s: string]: T } | ArrayLike<T>) => [string, T][] = (/* #__PURE__*/_pureAssign((/* #__PURE__*/_pureRef<typeof Object.entries>(ObjClass, \"entries\")), polyObjEntries));\r\n\r\n/**\r\n * The objValues() returns an array whose elements are values of enumerable string-keyed properties found\r\n * directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop\r\n * enumerates properties in the prototype chain as well. The order of the array returned by objValues()\r\n * is the same as that provided by a for...in loop.\r\n *\r\n * If you need the property keys, use objKeys() instead. If you need both the property keys and values, use objEntries() instead.\r\n * @since 0.9.7\r\n * @group Object\r\n * @group ArrayLike\r\n * @param value - The object that contains the properties and methods.\r\n * @returns An array containing the given object's own enumerable string-keyed property values.\r\n * @example\r\n * ```ts\r\n * objValues({ Hello: \"Darkness\", my: \"old\", friend: \".\" });\r\n * // [ \"Darkness\", \"old\", \".\" ]\r\n *\r\n * // Array-like object\r\n * objValues({ 0: \"a\", 1: \"b\", 2: \"c\" }));\r\n * // [ 'a', 'b', 'c']\r\n *\r\n * // Array-like object with random key ordering\r\n * objValues({ 100: \"a\", 2: \"b\", 7: \"c\" });\r\n * // [ 'b', 'c', 'a']\r\n * ```\r\n */\r\nexport const objValues: <T = any>(value: {} | { [s: string]: T } | ArrayLike<T>) => T[] = (/* #__PURE__*/_pureAssign((/* #__PURE__*/_pureRef<typeof Object.values>(ObjClass, \"values\")), polyObjValues));\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { eMapValues, _createKeyValueMap, _assignMapValue } from \"../internal/map\";\r\nimport { objForEachKey } from \"../object/for_each_key\";\r\nimport { objFreeze } from \"../object/object\";\r\n\r\n/**\r\n * A type that identifies an enum class generated from a constant enum.\r\n * @group Enum\r\n * @typeParam E - The constant enum type\r\n *\r\n * Returned from {@link createEnum}\r\n */\r\nexport declare type EnumCls<E = any> = {\r\n    readonly [key in keyof E extends string | number | symbol ? keyof E : never]: key extends string ? E[key] : key\r\n} & { readonly [key in keyof E]: E[key] };\r\n\r\n/**\r\n * A type that identifies an object whose property values are generally mapped to the key of the source type.\r\n * @group Enum\r\n * @typeParam E - The source constant enum type which identifies the keys and values\r\n * @typeParam T - The resulting type with the keys from the source type.\r\n *\r\n * Returned from {@link createEnumKeyMap}\r\n */\r\nexport declare type EnumNameMap<E = any, T = { readonly [key in keyof E]: key extends string ? key : keyof E }> = {\r\n    readonly [key in keyof E extends string | number | symbol ? keyof E : never]: key extends string ? key : keyof E\r\n} & T;\r\n\r\n/**\r\n * A type that identifies an object whose property values are mapped to the resulting values of the source objects keys.\r\n * @group Enum\r\n * @typeParam E - The source type which identifies the keys.\r\n * @typeParam T - The resulting type with the keys from the source type.\r\n *\r\n * Returned from {@link createEnumValueMap}\r\n */\r\nexport declare type EnumValueMap<E = any, T = { readonly [key in keyof E]: E[keyof E] }> = {\r\n    readonly [key in keyof E extends string | number | symbol ? keyof E : never]: key extends string ? E[key] : E[key]\r\n} & T;\r\n\r\n/**\r\n * A type that maps the keys of E to the type of V.\r\n * @group Enum\r\n * @typeParam E - The type of object that defines the Key (typically a constant enum)\r\n * @typeParam V - The value type, typically `string`, `number` but may also be a complex type.\r\n * @typeParam T - The resulting type with the keys from the source type.\r\n *\r\n * Returned from {@link createSimpleMap}\r\n */\r\nexport declare type EnumTypeMap<E, V, T = { readonly [key in keyof E]: V }> = {\r\n    readonly [key in keyof E extends string ? keyof E : never]: V\r\n} & T;\r\n\r\n/**\r\n * Create a TypeScript style enum class which is a mapping that maps from the key -\\> value and the value -\\> key.\r\n * This is effectively the same as defining a non-constant enum, but this only repeats the \"Name\" of the enum value once.\r\n * @group Enum\r\n * @example\r\n * ```ts\r\n * const enum Animal {\r\n *    Dog = 0,\r\n *    Cat = 1,\r\n *    Butterfly = 2,\r\n *    Bear = 3\r\n * }\r\n * const Animals = createEnum<typeof Animal>({\r\n *    Dog: Animal.Dog,\r\n *    Cat: Animal.Cat,\r\n *    Butterfly: Animal.Butterfly,\r\n *    Bear: Animal.Bear\r\n * });\r\n * // You end up with an object that maps everything to the name\r\n * Animals.Dog === 0;           // true\r\n * Animals[0] === \"Dog\";        // true\r\n * Animals[\"Dog\"] === 0;        // true\r\n * Animals.Cat === 1;           // true\r\n * Animals[1] === \"Cat\";        // true\r\n * Animals[\"Cat\"] === 1;        // true\r\n * ```\r\n\r\n * @param values - The values to populate on the new object\r\n * @typeParam E - Identifies the const enum type being mapped\r\n * @returns A new frozen (immutable) object which looks and acts like a TypeScript Enum class.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createEnum<E>(values: { [key in keyof E]: E[keyof E] }): EnumCls<E> {\r\n    return _createKeyValueMap(values, eMapValues.Value, eMapValues.Key, objFreeze);\r\n}\r\n\r\n/**\r\n * Create a map object which contains both the property key and value which both map to the key,\r\n * E[key] =\\> key and E[value] =\\> key.\r\n * @group Enum\r\n * @example\r\n * ```ts\r\n * const enum Animal {\r\n *    Dog = 0,\r\n *    Cat = 1,\r\n *    Butterfly = 2,\r\n *    Bear = 3\r\n * }\r\n * const animalMap = createEnumKeyMap<typeof Animal>({\r\n *    Dog: Animal.Dog,\r\n *    Cat: Animal.Cat,\r\n *    Butterfly: Animal.Butterfly,\r\n *    Bear: Animal.Bear\r\n * });\r\n * // You end up with an object that maps everything to the name\r\n * animalMap.Dog === \"Dog\";         // true\r\n * animalMap[0] === \"Dog\";          // true\r\n * animalMap[\"Dog\"] === \"Dog\";      // true\r\n * animalMap.Cat === \"Cat\";         // true\r\n * animalMap[1] === \"Cat\";          // true\r\n * animalMap[\"Cat\"] === \"Cat\";      // true\r\n * // Helper function to always return the \"Name\" of the type of animal\r\n * function getAnimalType(type: string | number | Animal) {\r\n *     return animalMap[type];\r\n * }\r\n * ```\r\n * @param values - The values to populate on the new object\r\n * @typeParam E - Identifies the const enum type being mapped\r\n * @returns A new frozen (immutable) object which contains a property for each key and value that returns the value.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createEnumKeyMap<E>(values: { [key in keyof E]: E[keyof E] }): EnumNameMap<E> {\r\n    return _createKeyValueMap(values, eMapValues.Key, eMapValues.Key, objFreeze);\r\n}\r\n\r\n/**\r\n * Create a map object which contains both the perperty key and value which both map to the resulting value,\r\n * E[key] =\\> value and E[value] =\\> value.\r\n * @group Enum\r\n * @example\r\n * ```ts\r\n * const enum Animal {\r\n *    Dog = 0,\r\n *    Cat = 1,\r\n *    Butterfly = 2,\r\n *    Bear = 3\r\n * }\r\n * const animalMap = createEnumValueMap<typeof Animal>({\r\n *    Dog: Animal.Dog,\r\n *    Cat: Animal.Cat,\r\n *    Butterfly: Animal.Butterfly,\r\n *    Bear: Animal.Bear\r\n * });\r\n * // You end up with an object that maps everything to the name\r\n * animalMap.Dog === 0;     // true\r\n * animalMap[0] === 0;      // true\r\n * animalMap[\"Dog\"] === 0;  // true\r\n * animalMap.Cat === 1;     // true\r\n * animalMap[1] === 1;      // true\r\n * animalMap[\"Cat\"] === 1;  // true\r\n *\r\n * // Helper function to always return the \"Name\" of the type of animal\r\n * function getAnimalValue(type: string | number | Animal) {\r\n *     return animalMap[type];\r\n * }\r\n * ```\r\n\r\n * @param values - The values to populate on the new object\r\n * @typeParam E - Identifies the const enum type being mapped\r\n * @returns A new frozen (immutable) object which contains a property for each key and value that returns the value.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createEnumValueMap<E>(values: { [key in keyof E]: E[keyof E] }): EnumValueMap<E> {\r\n    return _createKeyValueMap(values, eMapValues.Value, eMapValues.Value, objFreeze);\r\n}\r\n\r\n/**\r\n * Create a map object which contains both the perperty key and value which both map to the requested\r\n * generic mapValue with a type of V, E[key] =\\> mapValue and E[value] =\\> mapValue.\r\n * @group Enum\r\n * @example\r\n * ```ts\r\n * const enum Animal {\r\n *    Dog = 0,\r\n *    Cat = 1,\r\n *    Butterfly = 2,\r\n *    Bear = 3\r\n * };\r\n * // Creates a simple mapping to a string value\r\n * const animalFamilyMap = createValueMap<typeof Animal, string>({\r\n *    Dog: [ Animal.Dog, \"Canidae\"],\r\n *    Cat: [ Animal.Cat, \"Felidae\"],\r\n *    Butterfly: [ Animal.Butterfly, \"Papilionidae\"],\r\n *    Bear: [ Animal.Bear, \"Ursidae\"]\r\n * });\r\n * // You end up with an object that maps everything to the name\r\n * animalMap.Dog === \"Canidae\";     // true with typeof animalMap.Dog is \"string\"\r\n * animalMap[0] === \"Canidae\";      // true with typeof animalMap[0] is \"string\"\r\n * animalMap[\"Dog\"] === \"Canidae\";  // true with typeof animalMap[\"Dog\"] is \"string\"\r\n * animalMap.Cat === \"Felidae\";     // true with typeof animalMap.Cat is \"string\"\r\n * animalMap[1] === \"Felidae\";      // true with typeof animalMap[1] is \"string\"\r\n * animalMap[\"Cat\"] === \"Felidae\";  // true with typeof animalMap[\"Cat\"] is \"string\"\r\n * ```\r\n * @param values - The values to populate on the new object\r\n * @typeParam E - Identifies the const enum type (eg. typeof Animal);\r\n * @typeParam V - Identifies the type of the mapping `string`; `number`; etc is not restructed to primitive types.\r\n * @returns A new frozen (immutable) object which contains a property for each key and value that returns the defiend mapped value.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createSimpleMap<E, V>(values: { [key in keyof E]: [ E[keyof E], V] }): EnumTypeMap<E, V> {\r\n    let mapClass: any = {};\r\n    objForEachKey(values, (key, value) => {\r\n        _assignMapValue(mapClass, key, value[1]);\r\n        _assignMapValue(mapClass, value[0], value[1]);\r\n    });\r\n\r\n    return objFreeze(mapClass);\r\n}\r\n\r\n/**\r\n * Create a strongly types map object which contains both the perperty key and value which both map\r\n * to the requested mapValue,\r\n * E[key] =\\> mapValue and E[value] =\\> mapValue.\r\n * - E = the const enum type (typeof Animal);\r\n * - V = Identifies the valid values for the keys, this should include both the enum numeric and string key of the type. The\r\n * resulting \"Value\" of each entry identifies the valid values withing the assignments.\r\n * @group Enum\r\n * @example\r\n * ```ts\r\n * // Create a strongly types map\r\n * const animalFamilyMap = createTypeMap<typeof Animal, {\r\n *     // Defined the enum lookups\r\n *     [Animal.Dog]: \"Canidae\",\r\n *     [Animal.Cat]: \"Felidae\",\r\n *     [Animal.Butterfly]: \"Papilionidae\",\r\n *     [Animal.Bear]: \"Ursidae\",\r\n *     // Defined Named reference\r\n *     Dog: \"Canidae\",\r\n *     Cat: \"Felidae\",\r\n *     Butterfly: \"Papilionidae\",\r\n *     Bear: \"Ursidae\",\r\n * }>({\r\n *     Dog: [ Animal.Dog, \"Canidae\"],\r\n *     Cat: [ Animal.Cat, \"Felidae\"],\r\n *     Butterfly: [ Animal.Butterfly, \"Papilionidae\"],\r\n *     Bear: [ Animal.Bear, \"Ursidae\"]\r\n * });\r\n * // You end up with a strongly types result for each value\r\n * animalMap.Dog === \"Canidae\";     // true with typeof animalMap.Dog is (const) \"Canidae\"\r\n * animalMap[0] === \"Canidae\";      // true with typeof animalMap[0] is \"Canidae\"\r\n * animalMap[\"Dog\"] === \"Canidae\";  // true with typeof animalMap[\"Dog\"] is \"Canidae\"\r\n * animalMap.Cat === \"Felidae\";     // true with typeof animalMap.Cat is \"Felidae\"\r\n * animalMap[1] === \"Felidae\";      // true with typeof animalMap[1] is \"Felidae\"\r\n * animalMap[\"Cat\"] === \"Felidae\";  // true with typeof animalMap[\"Cat\"] is \"Felidae\"\r\n *\r\n * or using an interface to define the direct string mappings\r\n *\r\n * interface IAnimalFamilyMap {\r\n *     Dog: \"Canidae\",\r\n *     Cat: \"Felidae\",\r\n *     Butterfly: \"Papilionidae\",\r\n *     Bear: \"Ursidae\"\r\n * }\r\n *\r\n * // Create a strongly types map\r\n * const animalFamilyMap = createTypeMap<typeof Animal, IAnimalFamilyMap & {\r\n *     // Defined the enum lookups\r\n *     [Animal.Dog]: \"Canidae\",\r\n *     [Animal.Cat]: \"Felidae\",\r\n *     [Animal.Butterfly]: \"Papilionidae\",\r\n *     [Animal.Bear]: \"Ursidae\"\r\n * }>({\r\n *     Dog: [ Animal.Dog, \"Canidae\"],\r\n *     Cat: [ Animal.Cat, \"Felidae\"],\r\n *     Butterfly: [ Animal.Butterfly, \"Papilionidae\"],\r\n *     Bear: [ Animal.Bear, \"Ursidae\"]\r\n * });\r\n *\r\n * // You also end up with a strongly types result for each value\r\n * animalMap.Dog === \"Canidae\";     // true with typeof animalMap.Dog is (const) \"Canidae\"\r\n * animalMap[0] === \"Canidae\";      // true with typeof animalMap[0] is \"Canidae\"\r\n * animalMap[\"Dog\"] === \"Canidae\";  // true with typeof animalMap[\"Dog\"] is \"Canidae\"\r\n * animalMap.Cat === \"Felidae\";     // true with typeof animalMap.Cat is \"Felidae\"\r\n * animalMap[1] === \"Felidae\";      // true with typeof animalMap[1] is \"Felidae\"\r\n * animalMap[\"Cat\"] === \"Felidae\";  // true with typeof animalMap[\"Cat\"] is \"Felidae\"\r\n * ```\r\n * @param values - The values to populate on the new object\r\n * @typeParam E - Identifies the enum type\r\n * @typeParam T - Identifies the return type that is being created via the mapping.\r\n * @returns A new frozen (immutable) object which contains a property for each key and value that returns the defined mapped value.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createTypeMap<E, T>(values: { [key in keyof E]: [ E[keyof E], T[keyof T] ] }): T {\r\n    return createSimpleMap<E, T>(values as any) as unknown as T;\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { safe } from \"../helpers/safe\";\r\nimport { UNDEFINED } from \"./constants\";\r\n\r\nconst GLOBAL_CONFIG_KEY = \"__tsUtils$gblCfg\";\r\n\r\ndeclare let globalThis: Window;\r\ndeclare let global: Window;\r\ndeclare let self: any;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal interface for holding the global polyfill symbols\r\n */\r\nexport interface _GlobalPolySymbols {\r\n    k: { [key: string ]: symbol },\r\n    s: { [sym: symbol ]: string },\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal interface for defining global test hooks\r\n */\r\nexport interface _GlobalTestHooks {\r\n    lzy?: boolean;\r\n}\r\n\r\nexport interface TsUtilsGlobalConfig extends _GlobalTestHooks {\r\n    gblSym?: _GlobalPolySymbols,\r\n}\r\n\r\nlet _globalCfg: { [key: string ]: any };\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper to get the current global value\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _getGlobalValue(): Window {\r\n    var result: Window;\r\n\r\n    if (typeof globalThis !== UNDEFINED) {\r\n        result = globalThis;\r\n    }\r\n\r\n    if (!result && typeof self !== UNDEFINED) {\r\n        result = self;\r\n    }\r\n\r\n    if (!result && typeof window !== UNDEFINED) {\r\n        result = window;\r\n    }\r\n\r\n    if (!result && typeof global !== UNDEFINED) {\r\n        result = global;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Gets/Sets the named value from the global config store, this is used to share configuration across\r\n * multiple modules. Primarily used for poly symbol and test hooks.\r\n * @returns The globally registered value.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _getGlobalConfig(): TsUtilsGlobalConfig {\r\n    if (!_globalCfg) {\r\n        let gbl = safe(_getGlobalValue).v || {};\r\n        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};\r\n    }\r\n\r\n    return _globalCfg;\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { _GlobalTestHooks, _getGlobalConfig } from \"../internal/global\";\r\nimport { objDefineProp } from \"../object/define\";\r\nimport { ICachedValue } from \"./cache\";\r\n\r\n/**\r\n * @internal\r\n * Internal flag which is set by the public {@link setBypassLazyCache}, should not be externally exported\r\n */\r\nexport let _globalLazyTestHooks: _GlobalTestHooks;\r\n\r\nexport function _initTestHooks() {\r\n    _globalLazyTestHooks = _getGlobalConfig();\r\n}\r\n\r\n/**\r\n * Interface of the object returned by the {@link getLazy} instance\r\n * @since 0.4.5\r\n * @group Lazy\r\n */\r\nexport interface ILazyValue<T> extends ICachedValue<T> {\r\n    /**\r\n     * Returns the current cached value from the lazy lookup, if the callback function has not yet occurred\r\n     * accessing the value will cause the lazy evaluation to occur and the result will be returned.\r\n     */\r\n    v: T,\r\n\r\n    /**\r\n     * Identifies if this instance is bypassing the internal caching mechanism which is used for testing\r\n     */\r\n    b?: boolean\r\n}\r\n\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally.\r\n * @since 0.4.5\r\n * @group Lazy\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns A new readonly {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = getLazy(() => callSomeExpensiveFunction());\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getLazy<T>(cb: () => T): ILazyValue<T> {\r\n    let lazyValue = { } as ILazyValue<T>;\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    lazyValue.b = _globalLazyTestHooks.lzy;\r\n\r\n    objDefineProp(lazyValue, \"v\", {\r\n        configurable: true,\r\n        get: function () {\r\n            let result = cb();\r\n            if (!_globalLazyTestHooks.lzy) {\r\n                // Just replace the value\r\n                objDefineProp(lazyValue, \"v\", {\r\n                    value: result\r\n                });\r\n            }\r\n\r\n            lazyValue.b = _globalLazyTestHooks.lzy;\r\n\r\n            return result;\r\n        }\r\n    });\r\n\r\n    return lazyValue;\r\n}\r\n\r\n/**\r\n * Test Hook function used to cause the internal caching of objects to be bypassed, this should never\r\n * be enabled for production as it has additional performance impact caused by the repetitive creation\r\n * of the lazy wrappers.\r\n * @group Lazy\r\n * @since 0.5.0\r\n * @param newValue - When `true` will cause all new lazy implementations to bypass the cached lookup.\r\n */\r\nexport function setBypassLazyCache(newValue: boolean) {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    _globalLazyTestHooks.lzy = newValue;\r\n}\r\n\r\n/**\r\n * Create and return a writable {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally. The\r\n * value may be set as many times as required, if the callback has not been called when you set the value\r\n * it will never get called.\r\n * @since 0.9.4\r\n * @group Lazy\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns A new writable {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = getWritableLazy(() => callSomeExpensiveFunction());\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * // Setting the value\r\n * let cachedValue = getWritableLazy(() => callSomeExpensiveFunction());\r\n * let theValue = \"new Value\";\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will set the value to be set explicitly and the callback\r\n *     // will now never occur and the result will be cached\r\n *     cachedValue.v = theValue;\r\n * }\r\n *\r\n * // Accessing the value again will cause the previously set value to be returned.\r\n * theValue === cachedValue.v;  // true\r\n * ```\r\n */\r\nexport function getWritableLazy<T>(cb: () => T): ILazyValue<T> {\r\n    let lazyValue = { } as ILazyValue<T>;\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    lazyValue.b = _globalLazyTestHooks.lzy;\r\n\r\n    let _setValue = (newValue: T) => {\r\n        // Just replace the value\r\n        objDefineProp(lazyValue, \"v\", {\r\n            value: newValue,\r\n            writable: true\r\n        });\r\n\r\n        if (lazyValue.b) {\r\n            delete lazyValue.b;\r\n        }\r\n    };\r\n\r\n    objDefineProp(lazyValue, \"v\", {\r\n        configurable: true,\r\n        get: function () {\r\n            let result = cb();\r\n            if (!_globalLazyTestHooks.lzy) {\r\n                // Just replace the value\r\n                _setValue(result);\r\n            }\r\n            \r\n            if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {\r\n                lazyValue.b = _globalLazyTestHooks.lzy;\r\n            }\r\n\r\n            return result;\r\n        },\r\n        set: _setValue\r\n    });\r\n\r\n    return lazyValue;\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE } from \"../internal/constants\";\r\nimport { objDefineProp } from \"../object/define\";\r\n\r\n/**\r\n * A generic interface for holding a cached value\r\n * @since 0.10.5\r\n * @group Helpers\r\n * @group Cache\r\n * @typeParam T - The type of the value to be cached\r\n * @example\r\n * ```ts\r\n * let cachedValue: ICachedValue<string> = {\r\n *    v: \"some value\"\r\n * };\r\n * ```\r\n */\r\nexport interface ICachedValue<T> {\r\n    /**\r\n     * Returns the current cached value\r\n     */\r\n    v: T,\r\n\r\n    /**\r\n     * Returns the current cached value\r\n     */\r\n    toJSON(): T;\r\n}\r\n\r\n/**\r\n * Create and return a readonly {@link ICachedValue} instance that is populated with the provided value.\r\n * This is useful when you want to cache a previously fetched value and return it without having to re-fetch\r\n * it again.\r\n * This is a lightweight version of {@link getLazy} which does not support any expiration or invalidation,\r\n * it also will not honor the {@link setBypassLazyCache} setting and will always return the provided value.\r\n * @since 0.10.5\r\n * @group Helpers\r\n * @group Cache\r\n * @typeParam T - The type of the value to be cached\r\n * @param value - The value to cache\r\n * @returns A new {@link ICachedValue} instance which wraps the provided value\r\n * @example\r\n * ```ts\r\n * let cachedValue = createCachedValue(\"some value\");\r\n * // cachedValue.v === \"some value\"\r\n *\r\n * JSON.stringify(cachedValue) === '{\"v\":\"some value\"}';\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createCachedValue<T>(value: T): ICachedValue<T> {\r\n    return objDefineProp({\r\n        toJSON: () => value\r\n    }, \"v\", { value }) as ICachedValue<T>;\r\n}\r\n\r\n/**\r\n * Create and return a readonly {@link ICachedValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * will not cause re-execution of the callback as the result from the first call is cached internally.\r\n * This is a lightweight version of {@link getLazy} which does not support any expiration or invalidation,\r\n * it also will not honor the {@link setBypassLazyCache} setting and will always return the provided value.\r\n * @since 0.10.5\r\n * @group Helpers\r\n * @group Cache\r\n * @typeParam T - The type of the value to be cached\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createDeferredCachedValue<T>(cb: () => T): ICachedValue<T> {\r\n    let theValue: any = {\r\n        toJSON: () => theValue.v\r\n    };\r\n\r\n    return objDefineProp(theValue as ICachedValue<T>, \"v\", {\r\n        get: () => {\r\n            let result = cb();\r\n            cb = NULL_VALUE;\r\n            objDefineProp(theValue, \"v\", { value: result });\r\n            return result;\r\n        },\r\n        configurable: true\r\n    });\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { _getGlobalValue } from \"../internal/global\";\r\nimport { ILazyValue, _globalLazyTestHooks, _initTestHooks, getLazy } from \"./lazy\";\r\nimport { ICachedValue, createCachedValue } from \"./cache\";\r\nimport { safe } from \"./safe\";\r\n\r\nconst WINDOW = \"window\";\r\n\r\ndeclare let WorkerGlobalScope: any;\r\ndeclare let self: any;\r\n\r\nlet _cachedGlobal: ICachedValue<Window>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Returns a function which will return the named global object if available, will return `null` if the object is not available.\r\n * @param getFn - The function to use to get the global object\r\n * @param instName - The name of the global object to get, may be any valid PropertyKey (string, number or symbol)\r\n * @returns A function which will return the named global object if available, the funcion will return `null` if the object is not available.\r\n */\r\nexport function _getGlobalInstFn<T>(getFn: (...args: unknown[]) => T, theArgs?: unknown[]): () => T | null | undefined {\r\n    let cachedValue: ICachedValue<T>;\r\n    return function() {\r\n        !_globalLazyTestHooks && _initTestHooks();\r\n        if (!cachedValue || _globalLazyTestHooks.lzy) {\r\n            cachedValue = createCachedValue(safe(getFn, theArgs).v);\r\n        }\r\n        \r\n        return cachedValue.v;\r\n    }\r\n}\r\n\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the named global\r\n * value if available, will return `null` if the named global object is not available or if the runtime\r\n * throws an exception when attempting to access the global object.\r\n * Unlike {@link getInst} the value is cached after the first access, so if the global value changes after\r\n * the initial fetch the original cached value is still returned.\r\n * @since 0.9.5\r\n * @group Environment\r\n * @group Lazy\r\n * @group Safe\r\n * @param name - The name of the global object to get, may be any valid PropertyKey (string, number or symbol)\r\n * @returns A new readonly {@link ILazyValue} instance which will lazily attempt to return the globally\r\n * available named instance.\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * window.myGlobal = \"Hello\";\r\n * let cachedValue = lazySafeGetInst(\"myGlobal\");\r\n * // cachedValue.v === \"Hello\"\r\n *\r\n * window.myGlobal = \"Darkness\";\r\n * // cachedValue.v === \"Hello\"\r\n *\r\n * let promiseCls = lazySafeGetInst(\"Promise\");\r\n * // null if Promise is not supported in the runtime\r\n * // otherwise the Promise class.\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function lazySafeGetInst<T>(name: string | number | symbol) : ILazyValue<T> {\r\n    return getLazy(() => safe(getInst<T>, [name]).v || UNDEF_VALUE);\r\n}\r\n\r\n/**\r\n * Returns the current global scope object, for a normal web page this will be the current\r\n * window, for a Web Worker this will be current worker global scope via \"self\". The internal\r\n * implementation returns the first available instance object in the following order\r\n * - globalThis (New standard)\r\n * - self (Will return the current window instance for supported browsers)\r\n * - window (fallback for older browser implementations)\r\n * - global (NodeJS standard)\r\n * - <null> (When all else fails)\r\n * While the return type is a Window for the normal case, not all environments will support all\r\n * of the properties or functions. And this caches the lookup of the global as in some environments\r\n * this can be an expensive operation.\r\n * @group Environment\r\n * @param useCached - [Optional] used for testing to bypass the cached lookup, when `true` this will\r\n * cause the cached global to be reset.\r\n */\r\nexport function getGlobal(useCached?: boolean): Window {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    if (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) {\r\n        _cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE);\r\n    }\r\n\r\n    return _cachedGlobal.v;\r\n}\r\n\r\n/**\r\n * Return the named global object if available, will return null if the object is not available.\r\n * @group Environment\r\n * @param name - The globally named object, may be any valid property key (string, number or symbol)\r\n * @param useCached - [Optional] used for testing to bypass the cached lookup, when `true` this will\r\n * cause the cached global to be reset.\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * window.myGlobal = \"Hello\";\r\n * let cachedValue = getInst(\"myGlobal\");\r\n * // cachedValue === \"Hello\"\r\n *\r\n * window.myGlobal = \"Darkness\";\r\n * // getInst(\"myGlobal\") === \"Darkness\"\r\n *\r\n * let promiseCls = getInst(\"Promise\");\r\n * // May throw if the global is not supported by the runtime\r\n * // otherwise the Promise class.\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getInst<T>(name: string | number | symbol, useCached?: boolean): T | null {\r\n    let gbl: any;\r\n    if (!_cachedGlobal || useCached === false) {\r\n        gbl = getGlobal(useCached);\r\n    } else {\r\n        gbl = _cachedGlobal.v;\r\n    }\r\n\r\n    if (gbl && gbl[name]) {\r\n        return gbl[name] as T;\r\n    }\r\n\r\n    // Test workaround, for environments where <global>.window (when global == window) doesn't return the base window\r\n    if (name === WINDOW) {\r\n        // tslint:disable-next-line: no-angle-bracket-type-assertion\r\n        try {\r\n            return window as T;\r\n        } catch (e) {\r\n            // Ignore\r\n        }\r\n    }\r\n\r\n    return NULL_VALUE;\r\n}\r\n\r\n/**\r\n * Identify whether the runtime contains a `document` object\r\n * @group Environment\r\n * @returns - True if a `document` exists\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function hasDocument(): boolean {\r\n    return !!( /*#__PURE__*/getDocument());\r\n}\r\n\r\n/**\r\n * Return the global `document` instance.\r\n * @group Environment\r\n * @returns\r\n */\r\nexport const getDocument = (/*#__PURE__*/_getGlobalInstFn<Document>(getInst, [\"document\"]));\r\n\r\n/**\r\n * Identify whether the runtime contains a `window` object\r\n * @group Environment\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function hasWindow(): boolean {\r\n    return !!( /*#__PURE__*/getWindow());\r\n}\r\n\r\n/**\r\n * Return the global `window` instance.\r\n * @group Environment\r\n * @returns\r\n */\r\nexport const getWindow = (/*#__PURE__*/_getGlobalInstFn<Window>(getInst, [WINDOW]));\r\n\r\n/**\r\n * Identify whether the runtimne contains a `navigator` object\r\n * @group Environment\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function hasNavigator(): boolean {\r\n    return !!( /*#__PURE__*/getNavigator());\r\n}\r\n\r\n/**\r\n * Returns the global `navigator` instance\r\n * @group Environment\r\n * @returns\r\n */\r\nexport const getNavigator = (/*#__PURE__*/_getGlobalInstFn<Navigator>(getInst, [\"navigator\"]));\r\n\r\n/**\r\n * Identifies whether the runtime contains a `history` object\r\n * @group Environment\r\n * @returns\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function hasHistory(): boolean {\r\n    return !!( /*#__PURE__*/getHistory());\r\n}\r\n\r\n/**\r\n * Returns the global `history` instance\r\n * @group Environment\r\n * @returns\r\n */\r\nexport const getHistory = (/*#__PURE__*/_getGlobalInstFn<History>(getInst, [\"history\"]));\r\n\r\n/**\r\n * Simple method to determine if we are running in a node environment\r\n * @group Environment\r\n * @returns True if you are\r\n */\r\nexport const isNode = (/*#__PURE__*/_getGlobalInstFn<boolean>(() => {\r\n    return !!( /*#__PURE__*/safe(() => (process && (process.versions||{}).node)).v);\r\n}));\r\n\r\n/**\r\n * Helper to identify if you are running as a Dedicated, Shared or Service worker\r\n * @group Environment\r\n * @returns True if the environment you are in looks like a Web Worker\r\n */\r\nexport const isWebWorker = (/*#__PURE__*/_getGlobalInstFn<boolean>(() => {\r\n    return !!( /*#__PURE__*/safe(() => self && self instanceof WorkerGlobalScope).v);\r\n}));\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE, SYMBOL, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { polyGetKnownSymbol, polyNewSymbol, polySymbolFor, polySymbolKeyFor } from \"../polyfills/symbol\";\r\nimport { WellKnownSymbols, _wellKnownSymbolMap } from \"./well_known\";\r\nimport { _createIs } from \"../helpers/base\";\r\nimport { _globalLazyTestHooks, _initTestHooks } from \"../helpers/lazy\";\r\nimport { ICachedValue, createCachedValue } from \"../helpers/cache\";\r\nimport { safe } from \"../helpers/safe\";\r\nimport { getInst } from \"../helpers/environment\";\r\n\r\nlet _symbol: ICachedValue<Symbol>;\r\nlet _symbolFor: ICachedValue<(key: string) => symbol>;\r\nlet _symbolKeyFor: ICachedValue<(sym: symbol) => string | undefined>;\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _initSymbol() {\r\n    _symbol = (/*#__PURE__*/createCachedValue(safe(getInst<Symbol>, [SYMBOL]).v));\r\n\r\n    return _symbol;\r\n}\r\n\r\nfunction _getSymbolKey<R>(key: string) {\r\n    let gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\r\n\r\n    return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE) as R;\r\n}\r\n\r\n/**\r\n * Checks if the type of value is a symbol.\r\n * @group Symbol\r\n * @param value - Value to be checked.\r\n * @return True if the value is a symbol, false otherwise.\r\n */\r\nexport const isSymbol: (value: any) => value is symbol = (/*#__PURE__*/_createIs<symbol>(\"symbol\"));\r\n\r\n/**\r\n * Helper to identify whether the runtime support the Symbols either via native or an installed polyfill\r\n * @group Symbol\r\n * @returns true if Symbol's are support otherwise false\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function hasSymbol(): boolean {\r\n    return !!( /*#__PURE__*/getSymbol());\r\n}\r\n\r\n/**\r\n * If Symbols are supported then attempt to return the named Symbol\r\n * @group Symbol\r\n * @returns The value of the named Symbol (if available)\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getSymbol(): Symbol {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n    \r\n    // Get the current lazy symbol or cause it to get initialized\r\n    return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;\r\n}\r\n\r\n/**\r\n * If Symbols are supported then get the property of the global Symbol, if Symbol's are\r\n * not supported and noPoly is true it returns null. Used to access the well known symbols.\r\n * @group Symbol\r\n * @param name - The property name to return (if it exists) for Symbol\r\n * @param noPoly - Flag indicating whether to return a polyfill if symbols are not supported.\r\n * @returns The value of the property if present\r\n * @example\r\n * ```ts\r\n * // If Symbol is supported in the runtime\r\n * getKnownSymbol(\"toStringTag\") === Symbol.toStringTag;                // true\r\n * getKnownSymbol(WellKnownSymbols.toStringTag) === Symbol.toStringTag; // true\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function getKnownSymbol<T = symbol>(name: string | WellKnownSymbols, noPoly?: boolean): T {\r\n    let knownName = _wellKnownSymbolMap[name];\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n\r\n    // Get the current lazy symbol or cause it to get initialized\r\n    let sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\r\n    \r\n    return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);\r\n}\r\n\r\n/**\r\n * Returns a new unique Symbol value. If noPoly is true and symbols are not supported\r\n * then this will return null.\r\n * @group Symbol\r\n * @param description - Description of the new Symbol object.\r\n * @param noPoly - Flag indicating whether to return a polyfil if symbols are not supported.\r\n * @returns The new symbol\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function newSymbol(description?: string | number, noPoly?: boolean): symbol {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n\r\n    // Get the current lazy symbol or cause it to get initialized\r\n    let sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\r\n\r\n    return sym.v ? (sym.v as any)(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);\r\n}\r\n\r\n/**\r\n * Returns a Symbol object from the global symbol registry matching the given key if found.\r\n * Otherwise, returns a new symbol with this key. This will always return a polyfill if symbols\r\n * are not supported.\r\n * @group Symbol\r\n * @param key - key to search for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function symbolFor(key: string): symbol {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n\r\n    // Cause lazy symbol to get initialized\r\n    _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || (/*#__PURE__*/createCachedValue(safe(_getSymbolKey<typeof Symbol.for>, [\"for\"]).v)));\r\n\r\n    return (_symbolFor.v || polySymbolFor)(key);\r\n}\r\n\r\n/**\r\n * Returns a key from the global symbol registry matching the given Symbol if found.\r\n * Otherwise, returns a undefined. This will always attempt to lookup the polyfill\r\n * implementation if symbols are not supported\r\n * @group Symbol\r\n * @param sym - Symbol to find the key for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function symbolKeyFor(sym: symbol): string | undefined {\r\n    !_globalLazyTestHooks && _initTestHooks();\r\n\r\n    // Cause lazy symbol to get initialized\r\n    _symbolKeyFor = ((!_globalLazyTestHooks.lzy ? _symbolKeyFor : 0) || (/*#__PURE__*/createCachedValue(safe(_getSymbolKey<typeof Symbol.keyFor>, [\"keyFor\"]).v)));\r\n\r\n    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { WellKnownSymbols, _wellKnownSymbolMap } from \"../symbol/well_known\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { POLYFILL_TAG, SYMBOL, TO_STRING } from \"../internal/constants\";\r\nimport { objHasOwn } from \"../object/has_own\";\r\nimport { asString } from \"../string/as_string\";\r\nimport { _GlobalPolySymbols, _getGlobalConfig } from \"../internal/global\";\r\nimport { strSubstring } from \"../string/substring\";\r\nimport { objKeys } from \"../object/object\";\r\n\r\nconst UNIQUE_REGISTRY_ID = \"_urid\";\r\nlet _polySymbols: _GlobalPolySymbols;\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _globalSymbolRegistry(): _GlobalPolySymbols {\r\n    if (!_polySymbols) {\r\n        let gblCfg = _getGlobalConfig();\r\n        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s:{} };\r\n    }\r\n\r\n    return _polySymbols;\r\n}\r\n\r\nlet _wellKnownSymbolCache: { [key in keyof typeof WellKnownSymbols ]: symbol };\r\n\r\n/**\r\n * Returns a new (polyfill) Symbol object for the provided description that's guaranteed to be unique.\r\n * Symbols are often used to add unique property keys to an object that won't collide with keys any\r\n * other code might add to the object, and which are hidden from any mechanisms other code will\r\n * typically use to access the object. That enables a form of weak encapsulation, or a weak form of\r\n * information hiding.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param description - The description of the symbol\r\n * @returns A new polyfill version of a Symbol object\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyNewSymbol(description?: string | number): symbol {\r\n    let theSymbol: symbol = {\r\n        description: asString(description),\r\n        toString: () => SYMBOL + \"(\" + description + \")\"\r\n    } as symbol;\r\n    \r\n    // Tag the symbol so we know it a polyfill\r\n    theSymbol[POLYFILL_TAG] = true;\r\n\r\n    return theSymbol;\r\n}\r\n\r\n/**\r\n * Returns a Symbol object from the global symbol registry matching the given key if found.\r\n * Otherwise, returns a new symbol with this key.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param key - key to search for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polySymbolFor(key: string): symbol {\r\n    let registry = _globalSymbolRegistry();\r\n    if (!objHasOwn(registry.k, key)) {\r\n        let newSymbol = polyNewSymbol(key);\r\n        let regId = objKeys(registry.s).length;\r\n        newSymbol[UNIQUE_REGISTRY_ID] = () => regId + \"_\" + newSymbol[TO_STRING]();\r\n        registry.k[key] = newSymbol;\r\n        registry.s[newSymbol[UNIQUE_REGISTRY_ID]()] = asString(key);\r\n    }\r\n\r\n    return registry.k[key];\r\n}\r\n\r\n/**\r\n * Returns a key from the global symbol registry matching the given Symbol if found.\r\n * Otherwise, returns a undefined.\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param sym - Symbol to find the key for.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polySymbolKeyFor(sym: symbol): string | undefined {\r\n    if (!sym || !sym[TO_STRING] || strSubstring(sym[TO_STRING](), 0, 6) != SYMBOL) {\r\n        throwTypeError((sym as any) + \" is not a symbol\");\r\n    }\r\n\r\n    const regId = sym[POLYFILL_TAG] && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();\r\n\r\n    return regId ? _globalSymbolRegistry().s[regId] : undefined;\r\n}\r\n\r\n/**\r\n * Returns the polyfill version of a well-known global symbol, this will only return\r\n * known values.\r\n * @example\r\n * ```ts\r\n * // Always returns the polyfill version, even if Symbols are supported in the runtime\r\n * polyGetKnownSymbol(\"toStringTag\") === polyGetKnownSymbol(\"toStringTag\");                // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) === polyGetKnownSymbol(\"toStringTag\"); // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== Symbol.toStringTag;                // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== Symbol.toStringTag; // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== polySymbolFor(\"toStringTag\");      // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== polySymbolFor(\"toStringTag\"); // true\r\n * polyGetKnownSymbol(\"toStringTag\") !== polyNewSymbol(\"toStringTag\");      // true\r\n * polyGetKnownSymbol(WellKnownSymbols.toStringTag) !== polyNewSymbol(\"toStringTag\"); // true\r\n * ```\r\n * @group Polyfill\r\n * @group Symbol\r\n * @param name - The property name to return (if it exists) for Symbol\r\n * @returns The value of the property if present\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyGetKnownSymbol(name: string | WellKnownSymbols): symbol {\r\n    !_wellKnownSymbolCache && (_wellKnownSymbolCache = {} as any);\r\n    let result: symbol;\r\n    let knownName: WellKnownSymbols = _wellKnownSymbolMap[name];\r\n    if (knownName) {\r\n        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + \".\" + knownName);\r\n    }\r\n\r\n    return result\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getKnownSymbol } from \"../symbol/symbol\";\r\nimport { WellKnownSymbols } from \"../symbol/well_known\";\r\nimport { isFunction, isStrictNullOrUndefined } from \"../helpers/base\";\r\n\r\n/**\r\n * Checks if the type of value looks like an iterator instance (contains a next function).\r\n *\r\n * @since 0.4.0\r\n * @group Type Identity\r\n * @group Iterator\r\n * @typeParam T - Identifies the return type of the iterator defaults to any\r\n * @param value - The value to be checked\r\n * @returns True if the value is an Iterator, otherwise false\r\n * @example\r\n * ```ts\r\n * isIterator(null);        // false\r\n * isIterator(undefined);   // false\r\n * isIterator(\"null\");      // false (Strings are iterable but not iterators)\r\n * isIterator([]);          // false (Arrays are iterable but not iterators)\r\n * isIterator({\r\n *     next: function() { return true }\r\n * });                      // true, iterators must contain a \"next\" function\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isIterator<T = any>(value: any): value is Iterator<T> {\r\n    return !!value && isFunction(value.next);\r\n}\r\n\r\n/**\r\n * Checks if the value looks like it is iterable, contains a [symbol.iterator].\r\n *\r\n * @since 0.4.0\r\n * @group Type Identity\r\n * @group Iterator\r\n * @typeParam T - Identifies the return type of the iterator\r\n * @param value - The value to be checked\r\n * @returns True if the value is an Iterable, otherwise false\r\n * @example\r\n * ```ts\r\n * isIterable(null);        // false\r\n * isIterable(undefined);   // false\r\n * isIterable(\"null\");      // true (Strings are iterable)\r\n * isIterable([]);          // true (Arrays are iterable)\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function isIterable<T = any>(value: any): value is Iterable<T> {\r\n    return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(WellKnownSymbols.iterator)]);\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, createCachedValue } from \"../helpers/cache\";\r\nimport { CALL, NULL_VALUE, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { getKnownSymbol } from \"../symbol/symbol\";\r\nimport { WellKnownSymbols } from \"../symbol/well_known\";\r\nimport { isIterator } from \"./iterator\";\r\n\r\nlet _iterSymbol: ICachedValue<symbol>;\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEach}\r\n * you CAN stop / break the iteration by returning -1 from the`callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elements to the iterator, the actual behavior\r\n * will depend on the iterator imeplementation.\r\n *\r\n * If the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes preceedence.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols,\r\n * if you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOf expects a `synchronous` function.\r\n * iterForOf does not wait for promises. Make sure you are aware of the implications while using\r\n * promises (or async functions) as forEach callback.\r\n *\r\n * @since 0.4.2\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param callbackfn - A `synchronous` function that accepts up to three arguments. iterForOf calls the\r\n * callbackfn function one time for each element returned by the iterator.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is\r\n * omitted, null or undefined the iterator will be used as the this value.\r\n * @throws Any exception thrown while processing the iterator\r\n * @example\r\n * ```ts\r\n * const items = {\r\n *     'item1': 'value1',\r\n *     'item2': 'value2',\r\n *     'item3': 'value3\r\n * };\r\n * const copyItems = [];\r\n *\r\n * iterForOf(items, (item) => {\r\n *   copyItems.push(item);\r\n *   // May return -1 to abort the iteration\r\n * });\r\n * ```\r\n */\r\nexport function iterForOf<T>(iter: Iterator<T> | Iterable<T>, callbackfn: (value: T, count?: number, iter?: Iterator<T>) => void | number, thisArg?: any): void {\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.iterator)));\r\n            iter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : NULL_VALUE;\r\n        }\r\n        \r\n        if (isIterator(iter)) {\r\n            let err: { e: any } = UNDEF_VALUE;\r\n            let iterResult: IteratorResult<T> = UNDEF_VALUE;\r\n            try {\r\n                let count = 0;\r\n                while(!(iterResult = iter.next()).done) {\r\n                    if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {\r\n                        break;\r\n                    }\r\n        \r\n                    count++;\r\n                }\r\n            } catch (failed) {\r\n                err = { e: failed };\r\n                if (iter.throw) {\r\n                    iterResult = NULL_VALUE;\r\n                    iter.throw(err);\r\n                }\r\n            } finally {\r\n                try {\r\n                    if (iterResult && !iterResult.done) {\r\n                        iter.return && iter.return(iterResult);\r\n                    }\r\n                } finally {\r\n                    if (err) {\r\n                        // eslint-disable-next-line no-unsafe-finally\r\n                        throw err.e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ArrSlice, CALL } from \"../internal/constants\";\r\n\r\n/**\r\n * The `fnApply` function calls the specified `fn` function with the given `thisArg` as the `this` value,\r\n * and the optional `argArray` arguments provided as an array (or an Array-Like Object).\r\n *\r\n * Normally, when calling a function, the value of `this` inside the function is the object that the\r\n * function was accessed on. With `fnApply()`, you can assign an arbitrary value as this when calling an\r\n * existing function, without first attaching the function to the object as a property. This allows you\r\n * to use methods of one object as generic utility functions.\r\n *\r\n * You can also use any kind of object which is ArrayLike as the second parameter. In practice, this means\r\n * that it needs to have a length property, and integer (\"index\") properties in the range (0..length - 1).\r\n * For example, you could use a NodeList, or a custom object like `{ 'length': 2, '0': 'eat', '1': 'bananas' }`.\r\n * You can also use `arguments`.\r\n *\r\n * @since 0.9.8\r\n * @group Function\r\n *\r\n * @param fn - The function to be called\r\n * @param thisArg - The value of `this` provided for the call to `fn`. If the function is not in strict mode,\r\n * `null` and `undefined` will be replaced with the global object, and primitive values will be converted to objects.\r\n * @param argArray - An array-like object, specifying the arguments with which `fn` should be called, or `null` or\r\n * `undefined` if no arguments should be provided to the function.\r\n * @returns The result of calling the function with the specified `this` value and arguments.\r\n * @example\r\n * ```ts\r\n * // min / max number in an array\r\n * let max = fnApply(Math.max, null, [ 21, 42, 84, 168, 7, 3 ]);\r\n * // 168\r\n *\r\n * let min = fnApply(Math.min, null, [ 21, 42, 84, 168, 7, 3 ]);\r\n * // 3\r\n *\r\n * const module1 = {\r\n *     prefix: \"Hello\",\r\n *     x: 21,\r\n *     getX() {\r\n *         return this.x;\r\n *     },\r\n *     log(value: string) {\r\n *         return this.prefix + \" \" + value + \" : \" + this.x\r\n *     }\r\n * };\r\n *\r\n * // The 'this' parameter of 'getX' is bound to 'module'.\r\n * module1.getX(); // 21\r\n * module1.log(\"Darkness\"); // Hello Darkness : 21\r\n *\r\n * // Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.\r\n * let module2 = {\r\n *     prefix: \"my\",\r\n *     x: 42\r\n * };\r\n *\r\n * // Call the function of module1 with module2 as it's this\r\n * fnApply(module1.getX, module2); // 42\r\n * fnApply(module1.log, module2, [ \"friend\" ]); // my friend : 42\r\n * ```\r\n */\r\nexport function fnApply<F extends (...args: any) => any, T>(fn: F, thisArg: T, argArray?: ArrayLike<any>): ReturnType<F> {\r\n    return fn.apply(thisArg, argArray);\r\n}\r\n\r\n/**\r\n * The `fnCall` function calls the function with the given `thisArg` as the `this` value and with\r\n * al of the `_args` provided as it's `arguments`.\r\n *\r\n * Note: This is almost identical to `fnApply`, except that the function arguments are passed to `fnCall`\r\n * individually as a list, while with `fnApply` that are combined into a single array argument.\r\n *\r\n * Normally, when calling a function, the value of `this` inside the function is the object that the\r\n * function was accessed on. With `fnCall()`, you can pass an arbitrary value as the `this` when calling an\r\n * existing function, without first attaching the function to the object as a property. This allows you\r\n * to use methods of one object as generic utility functions.\r\n *\r\n * @since 0.9.8\r\n * @group Function\r\n *\r\n * @param fn - The function to be called\r\n * @param thisArg - The value of `this` provided for the call to `fn`. If the function is not in strict mode,\r\n * `null` and `undefined` will be replaced with the global object, and primitive values will be converted to objects.\r\n * @param _args - The zero or more arguments to be passed to the `fn` function.\r\n * @returns The result of calling the function with the specified `this` value and arguments.\r\n * @example\r\n * ```ts\r\n * // min / max number in an array\r\n * let max = fnCall(Math.max, null, 21, 42, 84, 168, 7, 3);\r\n * // 168\r\n *\r\n * let min = fnCall(Math.min, null, 21, 42, 84, 168, 7, 3);\r\n * // 3\r\n *\r\n * const module1 = {\r\n *     prefix: \"Hello\",\r\n *     x: 21,\r\n *     getX() {\r\n *         return this.x;\r\n *     },\r\n *     log(value: string) {\r\n *         return this.prefix + \" \" + value + \" : \" + this.x\r\n *     }\r\n * };\r\n *\r\n * // The 'this' parameter of 'getX' is bound to 'module'.\r\n * module1.getX(); // 21\r\n * module1.log(\"Darkness\"); // Hello Darkness : 21\r\n *\r\n * // Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.\r\n * let module2 = {\r\n *     prefix: \"my\",\r\n *     x: 42\r\n * };\r\n *\r\n * // Call the function of module1 with module2 as it's this\r\n * fnCall(module1.getX, module2); // 42\r\n * fnCall(module1.log, module2, \"friend\"); // my friend : 42\r\n * ```\r\n */\r\nexport function fnCall<F extends (...args: any) => any, T>(fn: F, thisArg: T, ...argArray: any[]): ReturnType<F>;\r\n\r\n/**\r\n * The `fnCall` function calls the function with the given `thisArg` as the `this` value and with\r\n * al of the `_args` provided as it's `arguments.\r\n *\r\n * > This is almost identical to `fnApply`, except that the function arguments are passed to `fnCall`\r\n * individually as a list, while with `fnApply` that are combined into a single array argument.\r\n *\r\n * Normally, when calling a function, the value of `this` inside the function is the object that the\r\n * function was accessed on. With `fnCall()`, you can pass an arbitrary value as the `this` when calling an\r\n * existing function, without first attaching the function to the object as a property. This allows you\r\n * to use methods of one object as generic utility functions.\r\n *\r\n * @since 0.9.8\r\n * @group Function\r\n *\r\n * @param fn - The function to be called\r\n * @param thisArg - The value of `this` provided for the call to `fn`. If the function is not in strict mode,\r\n * `null` and `undefined` will be replaced with the global object, and primitive values will be converted to objects.\r\n * @param _args - The zero or more arguments to be passed to the `fn` function.\r\n * @returns The result of calling the function with the specified `this` value and arguments.\r\n * @example\r\n * ```ts\r\n * const module1 = {\r\n *     prefix: \"Hello\",\r\n *     x: 21,\r\n *     getX() {\r\n *         return this.x;\r\n *     },\r\n *     log(value: string) {\r\n *         return this.prefix + \" \" + value + \" : \" + this.x\r\n *     }\r\n * };\r\n *\r\n * // The 'this' parameter of 'getX' is bound to 'module'.\r\n * module1.getX(); // 21\r\n * module1.log(\"Darkness\"); // Hello Darkness : 21\r\n *\r\n * // Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.\r\n * let module2 = {\r\n *     prefix: \"my\",\r\n *     x: 42\r\n * };\r\n *\r\n * // Call the function of module1 with module2 as it's this\r\n * fnCall(module1.getX, module2); // 42\r\n * fnCall(module1.log, module2, \"friend\"); // my friend : 42\r\n * ```\r\n */\r\nexport function fnCall<F extends (...args: any) => any, T>(fn: F, thisArg: T): ReturnType<F> {\r\n    return fn.apply(thisArg, ArrSlice[CALL](arguments, 2));\r\n}\r\n\r\n/**\r\n * Creates a new function that when called will set the value of `thisArg` as the `this` keyword\r\n * value whrn calling the provided `fn` instance, and all of the arguments passed to the new\r\n * function will be passed along to the original provided instance.\r\n * @param fn - The function instance to be called\r\n * @param thisArg - The value to be used as the `this` when calling the `fn`\r\n * @returns The value returned by the original `fn` after executing with the provided `thisArg`.\r\n * @since 0.9.8\r\n * @group Function\r\n * @example\r\n * ```ts\r\n * const module1 = {\r\n *     x: 21,\r\n *     getX() {\r\n *         return this.x;\r\n *     },\r\n * };\r\n *\r\n * // The 'this' parameter of 'getX' is bound to 'module'.\r\n * console.log(module1.getX()); // 21\r\n *\r\n * // Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.\r\n * let module2 = {\r\n *     x: 42\r\n * };\r\n *\r\n * module2.getX = fnBind(module1.getX, module2);\r\n * module2.getX(); // 42\r\n *\r\n * // It can also be used to proxy to the original function from the new one\r\n * module2.getX = fnBind(module1.getX, module1);\r\n * module2.getX(); // 21\r\n * ```\r\n */\r\nexport function fnBind<F extends Function, T>(fn: F, thisArg: T, ...argArray: any[]): F;\r\n\r\n/**\r\n * Creates a new function that when called will set the value of `thisArg` as the `this` keyword\r\n * value whrn calling the provided `fn` instance, and all of the arguments passed to the new\r\n * function will be passed along to the original provided instance.\r\n * @param fn - The function instance to be called\r\n * @param thisArg - The value to be used as the `this` when calling the `fn`\r\n * @returns The value returned by the original `fn` after executing with the provided `thisArg`.\r\n * @since 0.9.8\r\n * @group Function\r\n * @example\r\n * ```ts\r\n * const module1 = {\r\n *     x: 21,\r\n *     getX() {\r\n *         return this.x;\r\n *     },\r\n * };\r\n *\r\n * // The 'this' parameter of 'getX' is bound to 'module'.\r\n * console.log(module1.getX()); // 21\r\n *\r\n * // Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.\r\n * let module2 = {\r\n *     x: 42\r\n * };\r\n *\r\n * module2.getX = fnBind(module1.getX, module2);\r\n * module2.getX(); // 42\r\n *\r\n * // It can also be used to proxy to the original function from the new one\r\n * module2.getX = fnBind(module1.getX, module1);\r\n * module2.getX(); // 21\r\n * ```\r\n */\r\nexport function fnBind<F extends Function, T>(fn: F, thisArg: T): F {\r\n    return fn.bind.apply(fn, ArrSlice[CALL](arguments, 1));\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { CALL, LENGTH } from \"../internal/constants\";\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array in ascending index order. It is not invoked for index properties\r\n * that have been deleted or are uninitialized. And unlike the ES6 forEach() you CAN stop or break the iteration by returning -1 from the\r\n * `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackfn - A `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one time for each element in the array.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEach expects a `synchronous` function.\r\n * arrForEach does not wait for promises. Make sure you are aware of the implications while using promises (or async functions) as forEach callback.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3'];\r\n * const copyItems = [];\r\n *\r\n * // before using for loop\r\n * for (let i = 0; i < items.length; i++) {\r\n *   copyItems.push(items[i]);\r\n * }\r\n *\r\n * // before using forEach()\r\n * items.forEach((item) => {\r\n *   copyItems.push(item);\r\n * });\r\n *\r\n * // after\r\n * arrForEach(items, (item) => {\r\n *   copyItems.push(item);\r\n *   // May return -1 to abort the iteration\r\n * });\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n * ```\r\n */\r\nexport function arrForEach<T = any>(theArray: ArrayLike<T>, callbackfn: (value: T, index: number, array: T[]) => void | number, thisArg?: any): void {\r\n    if (theArray) {\r\n        const len = theArray[LENGTH] >>> 0;\r\n        for (let idx = 0; idx < len; idx++) {\r\n            if (idx in theArray) {\r\n                if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ArrSlice, CALL, NULL_VALUE } from \"../internal/constants\";\r\n\r\n/**\r\n * The arrSlice() method returns a shallow copy of a portion of an array into a new array object\r\n * selected from start to end (end not included) where start and end represent the index of items\r\n * in that array. The original array will not be modified.\r\n *\r\n * The `arrSlice()` method is a copying method. It does not alter this but instead returns a shallow\r\n * copy that contains some of the same elements as the ones from the original array.\r\n *\r\n * The `arrSlice()` method preserves empty slots. If the sliced portion is sparse, the returned arra\r\n * is sparse as well.\r\n *\r\n * The `arrSlice()` method is generic. It only expects the this value to have a length property and\r\n * integer-keyed properties.\r\n *\r\n * For both start and end, a negative index can be used to indicate an offset from the end of the array.\r\n * For example, -2 refers to the second to last element of the array.\r\n * @since 0.9.3\r\n * @group Array\r\n * @group ArrayLike\r\n * @param start - Zero-based index at which to start extraction, converted to an integer.\r\n * - Negative index counts back from the end of the array — if start \\< 0, start + array.length is used.\r\n * - If start \\< -array.length or start is omitted, 0 is used.\r\n * - If start \\>= array.length, nothing is extracted.\r\n * @param end - Zero-based index at which to end extraction, converted to an integer. slice() extracts\r\n * up to but not including end.\r\n * - Negative index counts back from the end of the array — if end \\< 0, end + array.length is used.\r\n * - If end \\< -array.length, 0 is used.\r\n * - If end \\>= array.length or end is omitted, array.length is used, causing all elements until the\r\n * end to be extracted.\r\n * - If end is positioned before or at start after normalization, nothing is extracted.\r\n * @example\r\n * ```ts\r\n * const lyrics = [\"Hello\", \"Darkness\", \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\", \"talk\" ];\r\n *\r\n * arrSlice(lyrics);        // [ \"Hello\", \"Darkness\", \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\", \"talk\" ]\r\n * arrSlice(lyrics, 1, 3);  // [ \"Darkness\", \"my\" ]\r\n * arrSlicw(lyrics, 2);     // [ \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\", \"talk\" ]\r\n * arrSlice(lyrics, 2, 4);  // [ \"my\", \"old\" ]\r\n * arrSlice(lyrics, 1, 5);  // [ \"Darkness\", \"my\", \"old\", \"friend.\" ]\r\n * arrSlice(lyrics, -2);    // [ \"to\", \"talk\" ]\r\n * arrSlice(lyrics, 2, -1); // [ \"my\", \"old\", \"friend.\", \"I've\", \"come\", \"to\" ]\r\n * ```\r\n */\r\nexport function arrSlice<T>(theArray: ArrayLike<T>, start?: number, end?: number): T[] {\r\n    return ((theArray ? theArray[\"slice\"] : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { FUNCTION, ObjClass, OBJECT, PROTOTYPE } from \"../internal/constants\";\r\nimport { dumpObj } from \"../helpers/diagnostics\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { _pureAssign, _pureRef } from \"../internal/treeshake_helpers\";\r\n\r\n/**\r\n * Creates an object that has the specified prototype, and that optionally contains specified properties. This helper exists to avoid adding a polyfil\r\n * for older browsers that do not define Object.create eg. ES3 only, IE8 just in case any page checks for presence/absence of the prototype implementation.\r\n * Note: For consistency this will not use the Object.create implementation if it exists as this would cause a testing requirement to test with and without the implementations\r\n * @group Object\r\n * @param obj - Object to use as a prototype. May be null\r\n */\r\nexport const objCreate: (obj: any) => any = (/* #__PURE__*/_pureAssign((/* #__PURE__*/_pureRef<typeof Object.create>(ObjClass as any, \"create\")), polyObjCreate));\r\n\r\n/**\r\n * Creates an object that has the specified prototype, and that optionally contains specified properties. This helper exists to avoid adding a polyfil\r\n * for older browsers that do not define Object.create eg. ES3 only, IE8 just in case any page checks for presence/absence of the prototype implementation.\r\n * Note: For consistency this will not use the Object.create implementation if it exists as this would cause a testing requirement to test with and without the implementations\r\n * @group Polyfill\r\n * @group Object\r\n * @param obj - Object to use as a prototype. May be null\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function polyObjCreate(obj: any): any {\r\n    if (!obj) {\r\n        return {};\r\n    }\r\n\r\n    let type = typeof obj;\r\n    if (type !== OBJECT && type !== FUNCTION) {\r\n        throwTypeError(\"Prototype must be an Object or function: \" + dumpObj(obj));\r\n    }\r\n\r\n    function tempFunc() {}\r\n    tempFunc[PROTOTYPE] = obj;\r\n\r\n    return new (tempFunc as any)();\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, createCachedValue } from \"../helpers/cache\";\r\nimport { ObjClass, __PROTO__ } from \"../internal/constants\";\r\nimport { objForEachKey } from \"./for_each_key\";\r\n\r\nlet _isProtoArray: ICachedValue<boolean>;\r\n\r\n/**\r\n * The objSetPrototypeOf() method sets the prototype (i.e., the internal [Prototype] property) of a specified\r\n * object to another object or null.\r\n * @group Object\r\n * @param obj - The object which is to have it's prototype set.\r\n * @param proto - The object's new prototype (an object or null)\r\n * @returns The specified object.\r\n */\r\nexport function objSetPrototypeOf(obj: any, proto: object) {\r\n    let fn = ObjClass[\"setPrototypeOf\"] ||\r\n        // tslint:disable-next-line: only-arrow-functions\r\n        function (d: any, b: any) {\r\n            !_isProtoArray && (_isProtoArray = createCachedValue({ [__PROTO__]: [] } instanceof Array));\r\n            _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, (key: any, value: any) => d[key] = value );\r\n        };\r\n\r\n    return fn(obj, proto);\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { fnApply } from \"../funcs/funcs\";\r\nimport { ArrSlice, CALL, CONSTRUCTOR, NAME, NULL_VALUE, PROTOTYPE } from \"../internal/constants\";\r\nimport { objCreate } from \"../object/create\";\r\nimport { objDefine } from \"../object/define\";\r\nimport { objGetPrototypeOf } from \"../object/object\";\r\nimport { objSetPrototypeOf } from \"../object/set_proto\";\r\nimport { safe } from \"./safe\";\r\n\r\n/**\r\n * Defines the definition of the custom error constructor\r\n * Used by: {@link createCustomError}\r\n * @group Error\r\n */\r\nexport interface CustomErrorConstructor<T extends Error = Error> extends ErrorConstructor {\r\n    new(message?: string): T;\r\n    (message?: string): T;\r\n    readonly prototype: T;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createCustomError<T>(name: string, d: any, b: any): T {\r\n    safe(objDefine, [ d, NAME, { v: name, c: true, e: false }]);\r\n    d = objSetPrototypeOf(d, b);\r\n    function __() {\r\n        this[CONSTRUCTOR] = d;\r\n        safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);\r\n    }\r\n\r\n    d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : ((__ as any)[PROTOTYPE] = b[PROTOTYPE], new (__ as any)());\r\n\r\n    return d;\r\n}\r\n\r\nfunction  _setName(baseClass: any, name: string) {\r\n    name && (baseClass[NAME] = name);\r\n    //name && (baseClass[PROTOTYPE][NAME] = name);\r\n}\r\n\r\n/**\r\n * Create a Custom Error class which may be used to throw custom errors.\r\n * @group Error\r\n * @param name - The name of the Custom Error\r\n * @param constructCb - [Optional] An optional callback function to call when a\r\n * new Customer Error instance is being created.\r\n * @param errorBase - [Optional] (since v0.9.6) The error class to extend for this class, defaults to Error.\r\n * @returns A new Error `class`\r\n * @example\r\n * ```ts\r\n * import { createCustomError, isError } from \"@nevware21/ts-utils\";\r\n *\r\n * // For an error that just contains a message\r\n * let myCustomErrorError = createCustomError(\"MessageError\");\r\n *\r\n * try {\r\n *     throw new myCustomErrorError(\"Error Message!\");\r\n * } catch(e) {\r\n *      // e.name === MessageError\r\n *      // isError(e) === true;\r\n *      // Object.prototype.toString.call(e) === \"[object Error]\";\r\n * }\r\n *\r\n * // Or a more complex error object\r\n * interface MyCriticalErrorConstructor extends CustomErrorConstructor {\r\n *     new(message: string, file: string, line: number, col: number): MyCriticalError;\r\n *     (message: string, file: string, line: number, col: number): MyCriticalError;\r\n * }\r\n *\r\n * interface MyCriticalError extends Error {\r\n *     readonly errorId: number;\r\n *     readonly args: any[];        // Holds all of the arguments passed during construction\r\n * }\r\n *\r\n * let _totalErrors = 0;\r\n * let myCustomError = createCustomError<MyCriticalErrorConstructor>(\"CriticalError\", (self, args) => {\r\n *     _totalErrors++;\r\n *     self.errorId = _totalErrors;\r\n *     self.args = args;\r\n * });\r\n *\r\n * try {\r\n *     throw new myCustomError(\"Not Again!\");\r\n * } catch(e) {\r\n *      // e.name === CriticalError\r\n *      // isError(e) === true;\r\n *      // Object.prototype.toString.call(e) === \"[object Error]\";\r\n * }\r\n *\r\n * // ----------------------------------------------------------\r\n * // Extending another custom error class\r\n * // ----------------------------------------------------------\r\n *\r\n * let AppError = createCustomError(\"ApplicationError\");\r\n * let theAppError = new appError();\r\n *\r\n * isError(theAppError);                    // true\r\n * theAppError instanceof Error;            // true\r\n * theAppError instanceof AppError;         // true\r\n *\r\n * let StartupError = createCustomError(\"StartupError\", null, AppError);\r\n * let theStartupError = new StartupError();\r\n *\r\n * isError(theStartupError);                // true\r\n * theStartupError instanceof Error;        // true\r\n * theStartupError instanceof AppError;     // true\r\n * theStartupError instanceof StartupError; // true\r\n * ```\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function createCustomError<T extends ErrorConstructor = CustomErrorConstructor, B extends ErrorConstructor = ErrorConstructor>(\r\n    name: string,\r\n    constructCb?: ((self: any, args: IArguments) => void) | null,\r\n    errorBase?: B): T {\r\n\r\n    let theBaseClass = errorBase || Error;\r\n    let orgName = theBaseClass[PROTOTYPE][NAME];\r\n    let captureFn = Error.captureStackTrace;\r\n    return _createCustomError<T>(name, function (this: any) {\r\n        let _this = this;\r\n        let theArgs = arguments;\r\n        try {\r\n            safe(_setName, [theBaseClass, name]);\r\n            let _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;\r\n            if (_self !== _this) {\r\n                // Looks like runtime error constructor reset the prototype chain, so restore it\r\n                let orgProto = objGetPrototypeOf(_this);\r\n                if (orgProto !== objGetPrototypeOf(_self)) {\r\n                    objSetPrototypeOf(_self, orgProto);\r\n                }\r\n            }\r\n\r\n            // Make sure we only capture our stack details\r\n            captureFn && captureFn(_self, _this[CONSTRUCTOR]);\r\n    \r\n            // Run the provided construction function\r\n            constructCb && constructCb(_self, theArgs);\r\n    \r\n            return _self;\r\n        } finally {\r\n            safe(_setName, [theBaseClass, orgName]);\r\n        }\r\n    }, theBaseClass);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nlet _unsupportedError: CustomErrorConstructor;\r\n\r\n/**\r\n * Throw a custom `UnsupportedError` Error instance with the given message.\r\n * @group Error\r\n * @param message - The message to include in the exception\r\n * @example\r\n * ```ts\r\n * import { throwUnsupported } from \"@nevware21/ts-utils\";\r\n *\r\n * if (!window) {\r\n *     throwUnsupported(\"A window is needed for this operation\");\r\n * }\r\n * ```\r\n */\r\nexport function throwUnsupported(message?: string): never {\r\n    if (!_unsupportedError) {\r\n        // Lazily create the class\r\n        _unsupportedError = createCustomError(\"UnsupportedError\");\r\n    }\r\n\r\n    throw new _unsupportedError(message);\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { fnApply } from \"../funcs/funcs\";\r\nimport { isArray } from \"../helpers/base\";\r\nimport { ArrSlice, CALL, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { ITimerHandler, _createTimerHandler } from \"./handler\";\r\n\r\nfunction _createTimeoutWith(startTimer: boolean, overrideFn: TimeoutOverrideFn | TimeoutOverrideFuncs, theArgs: any[]): ITimerHandler {\r\n    let isArr = isArray(overrideFn);\r\n    let len = isArr ? overrideFn.length : 0;\r\n    let setFn: TimeoutOverrideFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;\r\n    let clearFn: ClearTimeoutOverrideFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;\r\n\r\n    let timerFn = theArgs[0];\r\n    theArgs[0] = function () {\r\n        handler.dn();\r\n        fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));\r\n    };\r\n    \r\n    let handler = _createTimerHandler(startTimer, (timerId?: any) => {\r\n        if (timerId) {\r\n            if (timerId.refresh) {\r\n                timerId.refresh();\r\n                return timerId;\r\n            }\r\n\r\n            fnApply(clearFn, UNDEF_VALUE, [ timerId ]);\r\n        }\r\n\r\n        return fnApply(setFn, UNDEF_VALUE, theArgs);\r\n    }, function (timerId: any) {\r\n        fnApply(clearFn, UNDEF_VALUE, [ timerId ]);\r\n    });\r\n\r\n    return handler.h;\r\n}\r\n\r\n/**\r\n * The signature of the override timeout function used to create a new timeout instance, it follows the same signature as\r\n * the native `setTimeout` API.\r\n * @since 0.4.4\r\n * @group Timer\r\n * @param callback - A function to be executed after the timer expires.\r\n * @param ms - The time, in milliseconds that the timer should wait before the specified function or code is executed.\r\n * If this parameter is omitted, a value of 0 is used, meaning execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by callback.\r\n * @return The returned timeoutID is a positive integer value which identifies the timer created by the call to setTimeout().\r\n * This value can be passed to clearTimeout() to cancel the timeout.\r\n */\r\nexport type TimeoutOverrideFn = <TArgs extends any[]>(callback: (...args: TArgs) => void, ms?: number, ...args: TArgs) => number | any;\r\n\r\n/**\r\n * The signatire of the function to override clearing a previous timeout created with the {@link TimeoutOverrideFn}, it will be passed\r\n * the result returned from the {@link TimeoutOverrideFn} call.\r\n * @since 0.4.5\r\n * @group Timer\r\n * @param timeoutId - The value returned from the previous {@link TimeoutOverrideFn}.\r\n */\r\nexport type ClearTimeoutOverrideFn = (timeoutId: number | any) => void;\r\n\r\n/**\r\n * Defines the array signature used to pass the override set and clean functions for creating a timeout.\r\n * The first index [0] is the set function to be used and the second index [1] is the clear function to be used.\r\n * @since 0.4.5\r\n * @group Timer\r\n */\r\nexport type TimeoutOverrideFuncs = [ TimeoutOverrideFn | null, ClearTimeoutOverrideFn | null ];\r\n\r\n/**\r\n * Creates and starts a timer which executes a function or specified piece of code once the timer expires, this is simular\r\n * to using `setTimeout` but provides a return object for cancelling and restarting (refresh) the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * let theTimeout = scheduleTimeout(() => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearTimeout() with the returned value from setTimeout() the returned\r\n * // handler instance can be used instead to cancel the timer\r\n * theTimeout.cancel();\r\n * theTimeout.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theTimeout.enabled = true;\r\n *\r\n * // You can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theTimeout.refresh();\r\n * ```\r\n */\r\nexport function scheduleTimeout<A extends any[]>(callback: (...args: A) => void, timeout: number, ...args: A): ITimerHandler;\r\n\r\n/**\r\n * Creates and starts a timer which executes a function or specified piece of code once the timer expires, this is simular\r\n * to using `setTimeout` but provides a return object for cancelling and restarting (refresh) the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * let theTimeout = scheduleTimeout(() => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearTimeout() with the returned value from setTimeout() the returned\r\n * // handler instance can be used instead to cancel the timer\r\n * theTimeout.cancel();\r\n * theTimeout.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theTimeout.enabled = true;\r\n *\r\n * // You can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theTimeout.refresh();\r\n * ```\r\n */\r\nexport function scheduleTimeout<A extends any[]>(callback: (...args: A) => void, timeout: number): ITimerHandler {\r\n    return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));\r\n}\r\n\r\n/**\r\n * Creates and starts a timer which executes a function or specified piece of code once the timer expires. The overrideFn will be\r\n * used to create the timer, this is simular to using `setTimeout` but provides a return object for cancelling and restarting\r\n * (refresh) the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param overrideFn - setTimeout override function this will be called instead of the `setTimeout`, if the value\r\n * of `overrideFn` is null or undefined it will revert back to the native `setTimeout`. May also be an array with contains\r\n * both the setTimeout and clearTimeout override functions, if either is not provided the default native functions will be used\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * let theTimeout = scheduleTimeoutWith(newSetTimeoutFn, () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearTimeout() with the returned value from setTimeout() the returned\r\n * // handler instance can be used instead to cancel the timer\r\n * theTimeout.cancel();\r\n * theTimeout.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theTimeout.enabled = true;\r\n *\r\n * // You can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theTimeout.refresh();\r\n * ```\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * // Your own \"clearTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newClearTimeoutFn(timeoutId: number) {\r\n *     overrideCalled ++;\r\n *     return clearTimeout( timeout);\r\n * }\r\n *\r\n * let theTimeout = scheduleTimeoutWith([newSetTimeoutFn, newClearTimeoutFn], () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearTimeout() with the returned value from setTimeout() the returned\r\n * // handler instance can be used instead to cancel the timer, internally this will call the newClearTimeoutFn\r\n * theTimeout.cancel();\r\n * theTimeout.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theTimeout.enabled = true;\r\n *\r\n * // You can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theTimeout.refresh();\r\n * ```\r\n */\r\nexport function scheduleTimeoutWith<A extends any[]>(overrideFn: TimeoutOverrideFn | TimeoutOverrideFuncs, callback: (...args: A) => void, timeout: number, ...args: A): ITimerHandler;\r\n\r\n/**\r\n * Creates and starts a timer which executes a function or specified piece of code once the timer expires. The overrideFn will be\r\n * used to create the timer, this is simular to using `setTimeout` but provides a return object for cancelling and restarting\r\n * (refresh) the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n *\r\n * @param overrideFn - setTimeout override function this will be called instead of the `setTimeout`, if the value\r\n * of `overrideFn` is null or undefined it will revert back to the native `setTimeout`. May also be an array with contains\r\n * both the setTimeout and clearTimeout override functions, if either is not provided the default native functions will be used\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * let theTimeout = scheduleTimeoutWith(newSetTimeoutFn, () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearTimeout() with the returned value from setTimeout() the returned\r\n * // handler instance can be used instead to cancel the timer\r\n * theTimeout.cancel();\r\n * theTimeout.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theTimeout.enabled = true;\r\n *\r\n * // You can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theTimeout.refresh();\r\n * ```\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * // Your own \"clearTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newClearTimeoutFn(timeoutId: number) {\r\n *     overrideCalled ++;\r\n *     return clearTimeout( timeout);\r\n * }\r\n *\r\n * let theTimeout = scheduleTimeoutWith([newSetTimeoutFn, newClearTimeoutFn], () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // Instead of calling clearTimeout() with the returned value from setTimeout() the returned\r\n * // handler instance can be used instead to cancel the timer, internally this will call the newClearTimeoutFn\r\n * theTimeout.cancel();\r\n * theTimeout.enabled;    // false\r\n *\r\n * // You can start the timer via enabled\r\n * theTimeout.enabled = true;\r\n *\r\n * // You can also \"restart\" the timer, whether it has previously triggered not not via the `refresh()`\r\n * theTimeout.refresh();\r\n * ```\r\n */\r\nexport function scheduleTimeoutWith<A extends any[]>(overrideFn: TimeoutOverrideFn | TimeoutOverrideFuncs, callback: (...args: A) => void, timeout: number): ITimerHandler {\r\n    return _createTimeoutWith(true, overrideFn, ArrSlice[CALL](arguments, 1));\r\n}\r\n\r\n/**\r\n * Creates a non-running (paused) timer which will execute a function or specified piece of code when enabled and the timer expires,\r\n * this is simular to using `scheduleTimeout` but the timer is not enabled (running) and you MUST call `refresh` to start the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.7.0\r\n * @group Timer\r\n *\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * let theTimeout = createTimeout(() => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // As the timer is not started you will need to call \"refresh\" to start the timer\r\n * theTimeout.refresh();\r\n *\r\n * // or set enabled to true\r\n * theTimeout.enabled = true;\r\n * ```\r\n */\r\nexport function createTimeout<A extends any[]>(callback: (...args: A) => void, timeout: number, ...args: A): ITimerHandler;\r\n\r\n/**\r\n * Creates a non-running (paused) timer which will execute a function or specified piece of code when enabled and the timer expires,\r\n * this is simular to using `scheduleTimeout` but the timer is not enabled (running) and you MUST call `refresh` to start the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.7.0\r\n * @group Timer\r\n *\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * let theTimeout = createTimeout(() => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // As the timer is not started you will need to call \"refresh\" to start the timer\r\n * theTimeout.refresh();\r\n *\r\n * // or set enabled to true\r\n * theTimeout.enabled = true;\r\n * ```\r\n */\r\nexport function createTimeout<A extends any[]>(callback: (...args: A) => void, timeout: number): ITimerHandler {\r\n    return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));\r\n}\r\n\r\n/**\r\n * Creates a non-running (paused) timer which will execute a function or specified piece of code when enabled once the timer expires.\r\n * The overrideFn will be used to create the timer, this is simular to using `scheduleTimeoutWith` but the timer is not enabled (running)\r\n * and you MUST call `refresh` to start the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.7.0\r\n * @group Timer\r\n *\r\n * @param overrideFn - setTimeout override function this will be called instead of the `setTimeout`, if the value\r\n * of `overrideFn` is null or undefined it will revert back to the native `setTimeout`. May also be an array with contains\r\n * both the setTimeout and clearTimeout override functions, if either is not provided the default native functions will be used\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * let theTimeout = createTimeoutWith(newSetTimeoutFn, () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // As the timer is not started you will need to call \"refresh\" to start the timer\r\n * theTimeout.refresh();\r\n *\r\n * // or set enabled to true\r\n * theTimeout.enabled = true;\r\n * ```\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * // Your own \"clearTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newClearTimeoutFn(timeoutId: number) {\r\n *     overrideCalled ++;\r\n *     return clearTimeout( timeout);\r\n * }\r\n *\r\n * let theTimeout = createTimeoutWith([newSetTimeoutFn, newClearTimeoutFn], () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // As the timer is not started you will need to call \"refresh\" to start the timer\r\n * theTimeout.refresh();\r\n *\r\n * // or set enabled to true\r\n * theTimeout.enabled = true;\r\n * ```\r\n */\r\nexport function createTimeoutWith<A extends any[]>(overrideFn: TimeoutOverrideFn | TimeoutOverrideFuncs, callback: (...args: A) => void, timeout: number, ...args: A): ITimerHandler;\r\n\r\n/**\r\n * Creates a non-running (paused) timer which will execute a function or specified piece of code when enabled once the timer expires.\r\n * The overrideFn will be used to create the timer, this is simular to using `scheduleTimeoutWith` but the timer is not enabled (running)\r\n * and you MUST call `refresh` to start the timer.\r\n *\r\n * The timer may be cancelled (cleared) by calling the `cancel()` function on the returned {@link ITimerHandler}, or\r\n * you can \"reschedule\" and/or \"restart\" the timer by calling the `refresh()` function on the returned {@link ITimerHandler}\r\n * instance\r\n *\r\n * @since 0.7.0\r\n * @group Timer\r\n *\r\n * @param overrideFn - setTimeout override function this will be called instead of the `setTimeout`, if the value\r\n * of `overrideFn` is null or undefined it will revert back to the native `setTimeout`. May also be an array with contains\r\n * both the setTimeout and clearTimeout override functions, if either is not provided the default native functions will be used\r\n * @param callback - The function to be executed after the timer expires.\r\n * @param timeout - The time, in milliseconds that the timer should wait before the specified\r\n * function or code is executed. If this parameter is omitted, a value of 0 is used, meaning\r\n * execute \"immediately\", or more accurately, the next event cycle.\r\n * @param args - Additional arguments which are passed through to the function specified by `callback`.\r\n * @returns A {@link ITimerHandler} instance which can be used to cancel the timeout.\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * let theTimeout = createTimeoutWith(newSetTimeoutFn, () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // As the timer is not started you will need to call \"refresh\" to start the timer\r\n * theTimeout.refresh();\r\n *\r\n * // or set enabled to true\r\n * theTimeout.enabled = true;\r\n * ```\r\n * @example\r\n * ```ts\r\n * let timeoutCalled = false;\r\n * // Your own \"setTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newSetTimeoutFn(callback: TimeoutOverrideFn) {\r\n *     overrideCalled ++;\r\n *     return setTimeout(callback, timeout);\r\n * }\r\n *\r\n * // Your own \"clearTimeout\" implementation to allow you to perform additional operations or possible wrap\r\n * // the callback to add timings.\r\n * function newClearTimeoutFn(timeoutId: number) {\r\n *     overrideCalled ++;\r\n *     return clearTimeout( timeout);\r\n * }\r\n *\r\n * let theTimeout = createTimeoutWith([newSetTimeoutFn, newClearTimeoutFn], () => {\r\n *     // This callback will be called after 100ms as this uses setTimeout()\r\n *     timeoutCalled = true;\r\n * }, 100);\r\n *\r\n * // As the timer is not started you will need to call \"refresh\" to start the timer\r\n * theTimeout.refresh();\r\n *\r\n * // or set enabled to true\r\n * theTimeout.enabled = true;\r\n * ```\r\n */\r\nexport function createTimeoutWith<A extends any[]>(overrideFn: TimeoutOverrideFn | TimeoutOverrideFuncs, callback: (...args: A) => void, timeout: number): ITimerHandler {\r\n    return _createTimeoutWith(false, overrideFn, ArrSlice[CALL](arguments, 1));\r\n}\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE } from \"../internal/constants\";\r\nimport { objDefineProp } from \"../object/define\";\r\n\r\nconst REF = \"ref\";\r\nconst UNREF = \"unref\";\r\nconst HAS_REF = \"hasRef\";\r\nconst ENABLED = \"enabled\";\r\n\r\n/**\r\n * A Timer handler which is returned from {@link scheduleTimeout} which contains functions to\r\n * cancel or restart (refresh) the timeout function.\r\n *\r\n * @since 0.4.4\r\n * @group Timer\r\n */\r\nexport interface ITimerHandler {\r\n    /**\r\n     * Cancels a timeout that was previously scheduled, after calling this function any previously\r\n     * scheduled timer will not execute.\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = scheduleTimeout(...);\r\n     * theTimer.cancel();\r\n     * ```\r\n     */\r\n    cancel(): void;\r\n\r\n    /**\r\n     * Reschedules the timer to call its callback at the previously specified duration\r\n     * adjusted to the current time. This is useful for refreshing a timer without allocating\r\n     * a new JavaScript object.\r\n     *\r\n     * Using this on a timer that has already called its callback will reactivate the timer.\r\n     * Calling on a timer that has not yet executed will just reschedule the current timer.\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = scheduleTimeout(...);\r\n     * // The timer will be restarted (if already executed) or rescheduled (if it has not yet executed)\r\n     * theTimer.refresh();\r\n     * ```\r\n     */\r\n    refresh(): ITimerHandler;\r\n\r\n    /**\r\n     * When called, requests that the event loop not exit so long when the ITimerHandler is active.\r\n     * Calling timer.ref() multiple times will have no effect. By default, all ITimerHandler objects\r\n     * will create \"ref'ed\" instances, making it normally unnecessary to call timer.ref() unless\r\n     * timer.unref() had been called previously.\r\n     * @since 0.7.0\r\n     * @returns the ITimerHandler instance\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Make sure the timer is referenced (the default) so that the runtime (Node) does not terminate\r\n     * // if there is a waiting referenced timer.\r\n     * theTimer.ref();\r\n     * ```\r\n     */\r\n    ref(): this;\r\n\r\n    /**\r\n     * When called, the any active ITimerHandler instance will not require the event loop to remain\r\n     * active (Node.js). If there is no other activity keeping the event loop running, the process may\r\n     * exit before the ITimerHandler instance callback is invoked. Calling timer.unref() multiple times\r\n     * will have no effect.\r\n     * @since 0.7.0\r\n     * @returns the ITimerHandler instance\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Unreference the timer so that the runtime (Node) may terminate if nothing else is running.\r\n     * theTimer.unref();\r\n     * ```\r\n     */\r\n    unref(): this;\r\n\r\n    /**\r\n     * If true, any running referenced `ITimerHandler` instance will keep the Node.js event loop active.\r\n     * @since 0.7.0\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Unreference the timer so that the runtime (Node) may terminate if nothing else is running.\r\n     * theTimer.unref();\r\n     * let hasRef = theTimer.hasRef(); // false\r\n     *\r\n     * theTimer.ref();\r\n     * hasRef = theTimer.hasRef(); // true\r\n     * ```\r\n     */\r\n    hasRef(): boolean;\r\n\r\n    /**\r\n     * Gets or Sets a flag indicating if the underlying timer is currently enabled and running.\r\n     * Setting the enabled flag to the same as it's current value has no effect, setting to `true`\r\n     * when already `true` will not {@link ITimerHandler.refresh | refresh}() the timer.\r\n     * And setting to `false` will {@link ITimerHandler.cancel | cancel}() the timer.\r\n     * @since 0.8.1\r\n     * @example\r\n     * ```ts\r\n     * let theTimer = createTimeout(...);\r\n     *\r\n     * // Check if enabled\r\n     * theTimer.enabled; // false\r\n     *\r\n     * // Start the timer\r\n     * theTimer.enabled = true;     // Same as calling refresh()\r\n     * theTimer.enabled; //true\r\n     *\r\n     * // Has no effect as it's already running\r\n     * theTimer.enabled = true;\r\n     *\r\n     * // Will refresh / restart the time\r\n     * theTimer.refresh()\r\n     *\r\n     * let theTimer = scheduleTimeout(...);\r\n     *\r\n     * // Check if enabled\r\n     * theTimer.enabled; // true\r\n     * ```\r\n     */\r\n    enabled: boolean;\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n */\r\nexport interface _TimerHandler {\r\n    /**\r\n     * The public handler to return to the caller\r\n     */\r\n    h: ITimerHandler,\r\n\r\n    /**\r\n     * The callback function that should be called when the timer operation\r\n     * has completed and will not automatically rescheduled\r\n     * @returns\r\n     */\r\n    dn: () => void\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Internal function to create and manage an ITimerHandler implementation, the object returned from this function\r\n * it directly used / returned by the pulic functions used to create timers (idle, interval and timeout)\r\n * @param startTimer - Should the timer be started as part of creating the handler\r\n * @param refreshFn - The function used to create/start or refresh the timer\r\n * @param cancelFn - The function used to cancel the timer.\r\n * @returns The new ITimerHandler instance\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createTimerHandler<T>(startTimer: boolean, refreshFn: (timerId: T) => T, cancelFn: (timerId: T) => void): _TimerHandler {\r\n    let ref = true;\r\n    let timerId: T = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;\r\n    let theTimerHandler: ITimerHandler;\r\n\r\n    function _unref() {\r\n        ref = false;\r\n        timerId && timerId[UNREF] && timerId[UNREF]();\r\n        return theTimerHandler;\r\n    }\r\n\r\n    function _cancel() {\r\n        timerId && cancelFn(timerId);\r\n        timerId = NULL_VALUE;\r\n    }\r\n\r\n    function _refresh() {\r\n        timerId = refreshFn(timerId);\r\n        if (!ref) {\r\n            _unref();\r\n        }\r\n\r\n        return theTimerHandler;\r\n    }\r\n\r\n    function _setEnabled(value: boolean) {\r\n        !value && timerId && _cancel();\r\n        value && !timerId && _refresh();\r\n    }\r\n\r\n    theTimerHandler = {\r\n        cancel: _cancel,\r\n        refresh: _refresh\r\n    } as any;\r\n\r\n    theTimerHandler[HAS_REF] = () => {\r\n        if (timerId && timerId[HAS_REF]) {\r\n            return timerId[HAS_REF]();\r\n        }\r\n\r\n        return ref;\r\n    };\r\n\r\n    theTimerHandler[REF] = () => {\r\n        ref = true;\r\n        timerId && timerId[REF] && timerId[REF]();\r\n        return theTimerHandler;\r\n    };\r\n\r\n    theTimerHandler[UNREF] = _unref;\r\n\r\n    theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {\r\n        get: () => !!timerId,\r\n        set: _setEnabled\r\n    });\r\n\r\n    return {\r\n        h: theTimerHandler,\r\n        dn: () => {\r\n            timerId = NULL_VALUE;\r\n        }\r\n    };\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { AwaitResponse } from \"../interfaces/await-response\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { FinallyPromiseHandler, RejectedPromiseHandler, ResolvedPromiseHandler } from \"../interfaces/types\";\r\nimport { REJECTED } from \"../internal/constants\";\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | Promise<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | Promise<T | TResult1 | TResult2>): T | TResult1 | TResult2 | Promise<T | TResult1 | TResult2>;\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | PromiseLike<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | PromiseLike<T | TResult1 | TResult2>): T | TResult1 | TResult2 | PromiseLike<T | TResult1 | TResult2>;\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait to be resolved or rejected.\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | IPromise<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2>): T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2> {\r\n    return doAwait(value as T, (value) => {\r\n        return cb ? cb({\r\n            status: \"fulfilled\",\r\n            rejected: false,\r\n            value: value\r\n        }) : value;\r\n    },\r\n    (reason) => {\r\n        return cb ? cb({\r\n            status: REJECTED,\r\n            rejected: true,\r\n            reason: reason\r\n        }) : reason;\r\n    });\r\n}\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | Promise<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | Promise<TResult1 | TResult2>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | PromiseLike<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | PromiseLike<TResult1 | TResult2>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | IPromise<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | IPromise<TResult1 | TResult2> {\r\n    let result: T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2> | PromiseLike<TResult1 | TResult2> = value;\r\n    \r\n    try {\r\n        if (isPromiseLike<T>(value)) {\r\n            if (resolveFn || rejectFn) {\r\n                result = value.then(resolveFn, rejectFn) as any;\r\n            }\r\n        } else {\r\n            try {\r\n                if (resolveFn) {\r\n                    result = resolveFn(value);\r\n                }\r\n            } catch (err) {\r\n                if (rejectFn) {\r\n                    result = rejectFn(err);\r\n                } else {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (finallyFn) {\r\n            doFinally(result as any, finallyFn);\r\n        }\r\n    }\r\n\r\n    return result as any;\r\n}\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | Promise<T>, finallyFn: FinallyPromiseHandler): T | Promise<T>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | PromiseLike<T>, finallyFn: FinallyPromiseHandler): T | PromiseLike<T>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | IPromise<T>, finallyFn: FinallyPromiseHandler): T | IPromise<T> {\r\n    let result = value;\r\n    if (finallyFn) {\r\n        if (isPromiseLike<T>(value)) {\r\n            if ((value as IPromise<T>).finally) {\r\n                result = (value as IPromise<T>).finally(finallyFn);\r\n            } else {\r\n                // Simulate finally if not available\r\n                result = value.then(\r\n                    function(value) {\r\n                        finallyFn();\r\n                        return value;\r\n                    }, function(reason: any) {\r\n                        finallyFn();\r\n                        throw reason;\r\n                    });\r\n            }\r\n        } else {\r\n            finallyFn();\r\n        }\r\n    }\r\n\r\n    return result;\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { dumpObj, getDocument, getInst, ICachedValue, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\n\r\nconst DISPATCH_EVENT = \"dispatchEvent\";\r\nlet _hasInitEvent: ICachedValue<boolean>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to determine if the document has the `initEvent` function\r\n * @param doc - The document to check\r\n * @returns\r\n */\r\nfunction _hasInitEventFn(doc: Document) {\r\n    let evt: any;\r\n    if (doc && doc.createEvent) {\r\n        evt = doc.createEvent(\"Event\");\r\n    }\r\n    \r\n    return (!!evt && evt.initEvent);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param target\r\n * @param evtName\r\n * @param populateEvent\r\n * @param useNewEvent\r\n */\r\nexport function emitEvent(target: any, evtName: string, populateEvent: (theEvt: Event | any) => Event | any, useNewEvent: boolean) {\r\n\r\n    let doc = getDocument();\r\n    !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [ doc ]).v));\r\n\r\n    let theEvt: Event = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {} as Event);\r\n    populateEvent && populateEvent(theEvt);\r\n\r\n    if (_hasInitEvent.v) {\r\n        theEvt.initEvent(evtName, false, true);\r\n    }\r\n\r\n    if (theEvt && target[DISPATCH_EVENT]) {\r\n        target[DISPATCH_EVENT](theEvt);\r\n    } else {\r\n        let handler = target[\"on\" + evtName];\r\n        if (handler) {\r\n            handler(theEvt);\r\n        } else {\r\n            let theConsole = getInst(\"console\");\r\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\r\n        }\r\n    }\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined,\r\n    throwTypeError, WellKnownSymbols, objToString, scheduleTimeout, ITimerHandler, getWindow, isNode,\r\n    getGlobal, objDefine, objDefineProp, iterForOf, isIterable, isArray, arrForEach, createCachedValue,\r\n    ICachedValue, safe, getInst, createCustomError\r\n} from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromisePendingProcessor } from \"./itemProcessor\";\r\nimport {\r\n    FinallyPromiseHandler, PromiseCreatorFn, PromiseExecutor, RejectedPromiseHandler, ResolvedPromiseHandler\r\n} from \"../interfaces/types\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { REJECTED, STR_PROMISE } from \"../internal/constants\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"./debug\";\r\n//#endif\r\n\r\nconst NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nconst UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\n\r\nlet _currentPromiseId: number[] = [];\r\nlet _uniquePromiseId = 0;\r\nlet _unhandledRejectionTimeout = 10;\r\nlet _aggregationError: ICachedValue<any>;\r\n\r\n/**\r\n * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent)\r\n */\r\ninterface _PromiseRejectionEvent extends Event {\r\n    /**\r\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/promise)\r\n     */\r\n    readonly promise: IPromise<any>;\r\n\r\n    /**\r\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/reason)\r\n     */\r\n    readonly reason: any;\r\n}\r\n\r\nlet _hasPromiseRejectionEvent: ICachedValue<_PromiseRejectionEvent>;\r\n\r\nfunction dumpFnObj(value: any) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n\r\n    return dumpObj(value);\r\n}\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) function _getCaller(prefix: string, start: number) {\r\n//#:(!DEBUG)     let stack = new Error().stack;\r\n//#:(!DEBUG)     if (stack) {\r\n//#:(!DEBUG)         let lines = stack.split(\"\\n\");\r\n//#:(!DEBUG)         if (lines.length > start) {\r\n//#:(!DEBUG)             return prefix + \":\" + arrSlice(lines, start, start + 5).join(\"\\n\") + \"\\n...\";\r\n//#:(!DEBUG)         }\r\n//#:(!DEBUG)     }\r\n//#:(!DEBUG)     return null;\r\n//#:(!DEBUG) }\r\n//#endif\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createAggregationError(values: any[]) {\r\n    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", (self, args) => {\r\n        self.errors = args[0];\r\n    })));\r\n\r\n    return new _aggregationError.v(values);\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>, ...additionalArgs: any): IPromise<T>;\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>): IPromise<T> {\r\n    let additionalArgs = arrSlice(arguments, 3);\r\n    let _state = ePromiseState.Pending;\r\n    let _hasResolved = false;\r\n    let _settledValue: T;\r\n    let _queue: (() => void)[] = [];\r\n    let _id = _uniquePromiseId++;\r\n    let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    let _handled = false;\r\n    let _unHandledRejectionHandler: ITimerHandler = null;\r\n    let _thePromise: IPromise<T>;\r\n    \r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    function _then<TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): IPromise<TResult1 | TResult2> {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n\r\n            let thenPromise = newPromise<TResult1, TResult2>(function (resolve, reject) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _getCaller(\"_then\", 7));\r\n                //#endif\r\n\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        let handler = _state === ePromiseState.Resolved ? onResolved : onRejected;\r\n                        let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n    \r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve as any, reject);\r\n                        } else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value as any);\r\n                        } else if (_state === ePromiseState.Rejected) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        } else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value as any);\r\n                        }\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n    \r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n    \r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n    \r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n    \r\n            return thenPromise;\r\n    \r\n        } finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    function _catch<TResult1 = T>(onRejected: RejectedPromiseHandler<TResult1>) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    function _finally<TResult1 = T, TResult2 = never>(onFinally: FinallyPromiseHandler): IPromise<TResult1 | TResult2> {\r\n        let thenFinally: any = onFinally;\r\n        let catchFinally: any = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function(value: TResult1 | TResult2) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            }\r\n    \r\n            catchFinally = function(reason: any) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            }\r\n        }\r\n\r\n        return _then<TResult1, TResult2>(thenFinally as any, catchFinally as any);\r\n    }\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    function _processQueue() {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            let pending = _queue.slice();\r\n            _queue = [];\r\n\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    function _createSettleIfFn(newState: ePromiseState, allowState: ePromiseState) {\r\n        return (theValue: T) => {\r\n            if (_state === allowState) {\r\n                if (newState === ePromiseState.Resolved && isPromiseLike(theValue)) {\r\n                    _state = ePromiseState.Resolving;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(\r\n                        _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Resolving),\r\n                        _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Resolving));\r\n                    return;\r\n                }\r\n\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === ePromiseState.Rejected && !_unHandledRejectionHandler) {\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Setting up unhandled rejection\");\r\n                    //#endif\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout)\r\n                }\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n\r\n    function _notifyUnhandledRejection() {\r\n        if (!_handled) {\r\n            // Mark as handled so we don't keep notifying\r\n            _handled = true;\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            } else {\r\n                let gbl = getWindow() || getGlobal();\r\n    \r\n                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe(getInst<_PromiseRejectionEvent>, [STR_PROMISE + \"RejectionEvent\"]).v));\r\n\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, (theEvt: any) => {\r\n                    objDefine(theEvt, \"promise\", { g: () => _thePromise });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    } as any;\r\n\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);\r\n    }\r\n\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol<symbol>(WellKnownSymbols.toStringTag)] = \"IPromise\";\r\n    }\r\n\r\n    let createStack: string;\r\n    //#if DEBUG\r\n    //#:(!{DEBUG}) createStack = _getCaller(\"Created\", 5);\r\n    //#endif\r\n    function _toString() {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (createStack ? \" @ \" + createStack : \"\");\r\n    }\r\n\r\n    _thePromise.toString = _toString;\r\n\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n\r\n        const _rejectFn = _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Pending);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(\r\n                _thePromise,\r\n                _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Pending),\r\n                _rejectFn);\r\n        } catch (e) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Exception thrown: \" + dumpFnObj(e));\r\n            //#endif\r\n            _rejectFn(e);\r\n        }\r\n\r\n        //#ifdef DEBUG\r\n        //#:(!DEBUG) _debugLog(_toString(), \"~Executing\");\r\n        //#endif\r\n    })();\r\n\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllPromise(newPromise: PromiseCreatorFn): <T>(input: Iterable<T | PromiseLike<T>>, ...additionalArgs: any) => IPromise<Awaited<T>[]> {\r\n    return function <T>(input: Iterable<T | PromiseLike<T>>): IPromise<Awaited<T>[]> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T>[]>((resolve, reject) => {\r\n            try {\r\n                let values = [] as any;\r\n                let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n                iterForOf(input, (item, idx) => {\r\n                    if (item) {\r\n                        pending++;\r\n                        doAwait(item, (value) => {\r\n                            // Set the result values\r\n                            values[idx] = value;\r\n                            if (--pending === 0) {\r\n                                resolve(values);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value - Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createResolvedPromise(newPromise: PromiseCreatorFn): <T>(value: T, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(value: T): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike<T>(value)) {\r\n            return value as unknown as IPromise<T>;\r\n        }\r\n    \r\n        return newPromise((resolve) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Resolving Promise\");\r\n            //#endif\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRejectedPromise(newPromise: PromiseCreatorFn): <T>(reason: any, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(reason: any): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise((_resolve, reject) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Rejecting Promise\");\r\n            //#endif\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function which when called will return a new Promise object that resolves to an array of\r\n * IPromiseResults from the input promises. The returned promise will resolve when all of the inputs'\r\n * promises have resolved or rejected, or if the input contains no promises. It will resolve only after\r\n * all input promises have been fulfilled (resolve or rejected).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllSettledPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>> {\r\n    return createCachedValue(function <T>(input: T, ..._args: any[]): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>((resolve, reject) => {\r\n            let values: { -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; } = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value) => {\r\n                    if (value.rejected) {\r\n                        values[idx] = {\r\n                            status: REJECTED,\r\n                            reason: value.reason\r\n                        };\r\n                    } else {\r\n                        values[idx] = {\r\n                            status: \"fulfilled\",\r\n                            value: value.value\r\n                        };\r\n                    }\r\n                \r\n                    if (--pending === 0) {\r\n                        resolve(values);\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise settles with the eventual state of the first promise that settles.\r\n * @description The returned promise is one of the promise concurrency methods. It's useful when you want\r\n * the first async task to complete, but do not care about its eventual state (i.e. it can either succeed\r\n * or fail).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the first promise to settle is fulfilled,\r\n * and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises,\r\n * the returned promise is still settled.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createRacePromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let isDone = false;\r\n\r\n            function processItem(item: any) {\r\n                doAwaitResponse(item, (value) => {\r\n                    if (!isDone) {\r\n                        isDone = true;\r\n                        if (value.rejected) {\r\n                            reject(value.reason);\r\n                        } else {\r\n                            resolve(value.value);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment\r\n * value. It rejects when all of the input's promises reject (including when an empty iterable is passed),\r\n * with an AggregateError containing an array of rejection reasons.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the any of the input's promises fulfills,\r\n * with this first fulfillment value. It rejects when all of the input's promises reject (including when\r\n * an empty iterable is passed), with an AggregateError containing an array of rejection reasons.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createAnyPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let theErros: Array<any> = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n            let isDone = false;\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value ) => {\r\n                    if (!value.rejected) {\r\n                        isDone = true;\r\n                        resolve(value.value);\r\n                        return;\r\n                    } else {\r\n                        theErros[idx] = value.reason;\r\n                    }\r\n\r\n                    if (--pending === 0 && !isDone) {\r\n                        reject(_createAggregationError(theErros));\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0 && !isDone) {\r\n                    // All promises were either resolved or where not a promise\r\n                    reject(_createAggregationError(theErros));\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise,\r\n    _createRejectedPromise, _createResolvedPromise\r\n} from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { timeoutItemProcessor } from \"./itemProcessor\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\nimport { ICachedValue } from \"@nevware21/ts-utils\";\r\n\r\nlet _allAsyncSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceAsyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anyAsyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Creates an asynchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the optional provided timeout value to schedule when the chained items will be ececuted.\r\n * @group Async\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createAsyncPromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T> {\r\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createAsyncAllPromise: <T>(input: Iterable<PromiseLike<T>>, timeout?: number) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createAsyncResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createAsyncRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\r\n    return _allAsyncSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function createAsyncRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function  createAsyncRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\r\n    return _raceAsyncCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createAsyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\r\n    return _anyAsyncCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\n\r\nexport type PromisePendingProcessor = (pending: PromisePendingFn[]) => void;\r\nexport type PromisePendingFn = () => void;\r\nexport type PromiseCreatorFn = <T, TResult2 = never>(newExecutor: PromiseExecutor<T>, ...extraArgs: any) => IPromise<T | TResult2>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor(pending: PromisePendingFn[]): void {\r\n    arrForEach(pending, (fn: PromisePendingFn) => {\r\n        try {\r\n            fn();\r\n        } catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleTimeout(() => {\r\n            syncItemProcessor(pending);\r\n        }, callbackTimeout);\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let options: any;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleIdleCallback((deadline: IdleDeadline) => {\r\n            syncItemProcessor(pending);\r\n        }, options);\r\n    };\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { _pureAssign, _pureRef } from \"./treeshake_helpers\";\r\n\r\n// These constants are currently NOT exported directly, we may export them later associated with a frozen namespace (maybe)\r\n// For now do NOT expect that we will export these values.\r\n\r\nexport const UNDEF_VALUE: undefined = undefined;\r\nexport const NULL_VALUE: null = null;\r\n\r\nexport const EMPTY = \"\";\r\nexport const FUNCTION = \"function\";\r\nexport const OBJECT = \"object\";\r\nexport const PROTOTYPE = \"prototype\";\r\nexport const __PROTO__ = \"__proto__\";\r\nexport const UNDEFINED = \"undefined\";\r\nexport const CONSTRUCTOR = \"constructor\";\r\nexport const SYMBOL = \"Symbol\";\r\nexport const POLYFILL_TAG = \"_polyfill\";\r\nexport const LENGTH = \"length\";\r\nexport const NAME = \"name\";\r\nexport const CALL = \"call\";\r\nexport const TO_STRING = \"toString\";\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport const ObjClass = (/*#__PURE__*/_pureAssign(Object));\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport const ObjProto = (/*#__PURE__*/_pureRef<typeof Object.prototype>(ObjClass, PROTOTYPE));\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport const StrCls = (/*#__PURE__*/_pureAssign(String));\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport const StrProto = (/*#__PURE__*/_pureRef<typeof String.prototype>(StrCls, PROTOTYPE)) as String;\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport const MathCls = (/*#__PURE__*/_pureAssign(Math)) as Math;\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport const ArrCls = (/*#__PURE__*/_pureAssign(Array));\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport const ArrProto = (/*#__PURE__*/_pureRef<typeof ArrCls.prototype>(ArrCls, PROTOTYPE));\r\n\r\n/**\r\n * @ignore\r\n *\r\n */\r\nexport const ArrSlice = (/*#__PURE__*/_pureRef<typeof ArrProto.slice>(ArrProto, \"slice\"));","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nexport const STR_PROMISE = \"Promise\";\r\nexport const DONE = \"done\";\r\nexport const VALUE = \"value\";\r\nexport const ITERATOR = \"iterator\";\r\nexport const RETURN = \"return\";\r\nexport const REJECTED = \"rejected\";","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"./promise/asyncPromise\";\r\nimport { objForEachKey } from \"@nevware21/ts-utils\";\r\nimport { PolyPromise } from \"./polyfills/promise\";\r\n\r\ndeclare var Promise: any;\r\n\r\n(function () {\r\n    const promisePolyfills = {\r\n        \"all\": createAsyncAllPromise,\r\n        \"resolved\": createAsyncResolvedPromise,\r\n        \"rejected\": createAsyncRejectedPromise,\r\n        \"allSettled\": createAsyncAllSettledPromise\r\n    };\r\n\r\n    if (!Promise) {\r\n        Promise = PolyPromise;\r\n    } else {\r\n        // Add Object polyfills\r\n        let PromiseClass = Promise;\r\n        if (PromiseClass) {\r\n            objForEachKey(promisePolyfills, (key, value) => {\r\n                if (!PromiseClass[key]) {\r\n                    PromiseClass[key] = value;\r\n                }\r\n            });\r\n        }\r\n    }\r\n})();\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ObjClass } from \"../internal/constants\";\r\nimport { _pureRef } from \"../internal/treeshake_helpers\";\r\n\r\n/**\r\n * The objGetOwnPropertyDescriptor() method returns an object describing the configuration of a specific property on\r\n * a given object (that is, one directly present on an object and not in the object's prototype chain). The object\r\n * returned is mutable but mutating it has no effect on the original property's configuration.\r\n * @since 0.4.3\r\n * @group Object\r\n * @param target - Object that contains the property.\r\n * @param prop - Name of the property.\r\n * @returns A property descriptor of the given property if it exists on the object, otherwise undefined.\r\n *\r\n * @example\r\n * ```ts\r\n * o = {};\r\n * objDefineProp(o, 'qux', {\r\n *   value: 8675309,\r\n *   writable: false,\r\n *   enumerable: false\r\n * });\r\n * d = objGetOwnPropertyDescriptor(o, 'qux');\r\n * // d is {\r\n * //   value: 8675309,\r\n * //   writable: false,\r\n * //   enumerable: false,\r\n * //   configurable: false\r\n * // }\r\n *\r\n * objGetOwnPropertyDescriptor('foo', 0);\r\n * // TypeError: \"foo\" is not an object  // ES5 code\r\n *\r\n * objGetOwnPropertyDescriptor('foo', 0);\r\n * // Object returned by ES2015 code: {\r\n * //   configurable: false,\r\n * //   enumerable: true,\r\n * //   value: \"f\",\r\n * //   writable: false\r\n * // }\r\n * ```\r\n * Note: In ES5, if the first argument to this method is not an object (a primitive), then it will cause a TypeError. In ES2015, a non-object first argument will be coerced to an object at first.\r\n */\r\nexport const objGetOwnPropertyDescriptor: (target: any, prop: PropertyKey) => PropertyDescriptor | undefined = (/* #__PURE__ */_pureRef<typeof Object.getOwnPropertyDescriptor>(ObjClass as any, \"getOwnPropertyDescriptor\"));","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { StrCls } from \"../internal/constants\";\r\nimport { _pureAssign } from \"../internal/treeshake_helpers\";\r\n\r\n/**\r\n * The asString() method returns a string representing the value by\r\n * explicitly using `String(`value`)`.\r\n *\r\n * @since 0.4.3\r\n * @group String\r\n * @group Conversion\r\n * @group Value\r\n * @param value - The value to get a string representation of\r\n * @example\r\n * ```ts\r\n * const arr = [ 1, 2, 3];\r\n * asString(arr);       // \"1,2,3\"\r\n * asString(null);      // \"null\"\r\n * asString(undefined); // \"undefined\"\r\n * asString(42);        // \"42\"\r\n * asString(Symbol.for(\"Hello\"));   // \"Symbol(Hello)\"\r\n * ```\r\n */\r\nexport const asString: (value: any) => string = (/* #__PURE__ */_pureAssign(StrCls));\r\n","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createEnumKeyMap } from \"../helpers/enum\";\r\n\r\n/**\r\n * Identifies the Symbol static properties which are symbols themselves as a constant\r\n * enum to aid in minification when fetching them from the global symbol implementation.\r\n *\r\n * See: [Well Known Symbols](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol#well-known_symbols)\r\n * @group Symbol\r\n */\r\nexport const enum WellKnownSymbols {\r\n    /**\r\n     * The Symbol.asyncIterator symbol is a builtin symbol that is used to access an\r\n     * object's `Symbol.asyncIterator` method. In order for an object to be async iterable,\r\n     * it must have a Symbol.asyncIterator key.\r\n     *\r\n     * See: [Symbol.asyncIterator](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator)\r\n     */\r\n    asyncIterator = 0,\r\n\r\n    /**\r\n     * The `Symbol.hasInstance` well-known symbol is used to determine if a constructor\r\n     * object recognizes an object as its instance. The instanceof operator's behavior\r\n     * can be customized by this symbol.\r\n     *\r\n     * See: [Symbol.hasInstance](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance)\r\n     */\r\n    hasInstance = 1,\r\n\r\n    /**\r\n     * The `Symbol.isConcatSpreadable` symbol (Symbol.isConcatSpreadable) can be defined as an\r\n     * own or inherited property and its value is a boolean. It can control behavior for\r\n     * arrays and array-like objects:\r\n     * - For array objects, the default behavior is to spread (flatten) elements.\r\n     * Symbol.isConcatSpreadable can avoid flattening in these cases.\r\n     * - For array-like objects, the default behavior is no spreading or flattening.\r\n     * Symbol.isConcatSpreadable can force flattening in these cases.\r\n     *\r\n     * See: [Symbol.isConcatSpreadable](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable)\r\n     */\r\n    isConcatSpreadable = 2,\r\n\r\n    /**\r\n     * Whenever an object needs to be iterated (such as at the beginning of a for..of loop),\r\n     * its `Symbol.iterator` method is called with no arguments, and the returned iterator is used\r\n     * to obtain the values to be iterated.\r\n     *\r\n     * See: [Symbol.iterator](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)\r\n     */\r\n    iterator = 3,\r\n\r\n    /**\r\n     * This function is also used to identify if objects have the behavior of regular expressions.\r\n     * For example, the methods String.prototype.startsWith(), String.prototype.endsWith() and\r\n     * String.prototype.includes(), check if their first argument is a regular expression and\r\n     * will throw a TypeError if they are. Now, if the match symbol is set to false (or a Falsy\r\n     * value), it indicates that the object is not intended to be used as a regular expression object.\r\n     *\r\n     * See: [Symbol.match](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match)\r\n     */\r\n    match = 4,\r\n\r\n    /**\r\n     * The `Symbol.matchAll` well-known symbol returns an iterator, that yields matches of the regular\r\n     * expression against a string. This function is called by the String.prototype.matchAll() method.\r\n     *\r\n     * See: [Symbol.matchAll](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/matchAll)\r\n     */\r\n    matchAll = 5,\r\n\r\n    /**\r\n     * The `Symbol.replace` well-known symbol specifies the method that replaces matched substrings\r\n     * of a string. This function is called by the String.prototype.replace() method.\r\n     *\r\n     * For more information, [RegExp.prototype[Symbol.replace]](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp/\\@\\@replace)()\r\n     * and [String.prototype.replace](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replace)().\r\n     *\r\n     * See: [Symbol.replace](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace)\r\n     */\r\n    replace = 6,\r\n\r\n    /**\r\n     * The `Symbol.search` well-known symbol specifies the method that returns the index within a\r\n     * string that matches the regular expression. This function is called by the\r\n     * [String.prototype.search()](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/search)\r\n     * method.\r\n     *\r\n     * For more information, see [RegExp.prototype[\\@\\@search]](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp/\\@\\@search)()\r\n     * and [String.prototype.search()](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/search).\r\n     *\r\n     * See: [Symbol.species](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species)\r\n     */\r\n    search = 7,\r\n\r\n    /**\r\n     * The well-known symbol `Symbol.species` specifies a function-valued property that the constructor\r\n     * function uses to create derived objects.\r\n     * See: [Symbol.species](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species)\r\n     */\r\n    species = 8,\r\n\r\n    /**\r\n     * The `Symbol.split` well-known symbol specifies the method that splits a string at the indices\r\n     * that match a regular expression. This function is called by the String.prototype.split() method.\r\n     *\r\n     * For more information, see [RegExp.prototype[\\@\\@split]](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp/\\@\\@split)()\r\n     * and [String.prototype.split()](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/split).\r\n     * See: [Symbol.split](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/split)\r\n     */\r\n    split = 9,\r\n\r\n    /**\r\n     * With the help of the `Symbol.toPrimitive` property (used as a function value), an object can be\r\n     * converted to a primitive value. The function is called with a string argument hint, which\r\n     * specifies the preferred type of the result primitive value. The hint argument can be one of\r\n     * \"number\", \"string\", and \"default\".\r\n     *\r\n     * See: [Symbol.toPrimitive](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)\r\n     */\r\n    toPrimitive = 10,\r\n\r\n    /**\r\n     * The `Symbol.toStringTag` well-known symbol is a string valued property that is used in the\r\n     * creation of the default string description of an object. It is accessed internally by the\r\n     * [Object.prototype.toString](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/toString)()\r\n     * method.\r\n     *\r\n     * See: [Symbol.toStringTag](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag)\r\n     */\r\n    toStringTag = 11,\r\n\r\n    /**\r\n     * The `Symbol.unscopables` well-known symbol is used to specify an object value of whose own\r\n     * and inherited property names are excluded from the with environment bindings of the associated\r\n     * object.\r\n     *\r\n     * See: [Symbol.unscopables](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables)\r\n     */\r\n    unscopables = 12\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n */\r\nexport const _wellKnownSymbolMap = /*#__PURE__*/createEnumKeyMap<typeof WellKnownSymbols>({\r\n    asyncIterator: WellKnownSymbols.asyncIterator,\r\n    hasInstance: WellKnownSymbols.hasInstance,\r\n    isConcatSpreadable: WellKnownSymbols.isConcatSpreadable,\r\n    iterator: WellKnownSymbols.iterator,\r\n    match: WellKnownSymbols.match,\r\n    matchAll: WellKnownSymbols.matchAll,\r\n    replace: WellKnownSymbols.replace,\r\n    search: WellKnownSymbols.search,\r\n    species: WellKnownSymbols.species,\r\n    split: WellKnownSymbols.split,\r\n    toPrimitive: WellKnownSymbols.toPrimitive,\r\n    toStringTag: WellKnownSymbols.toStringTag,\r\n    unscopables: WellKnownSymbols.unscopables\r\n});\r\n\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { REJECTED } from \"./constants\";\r\n\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport const enum ePromiseState {\r\n    Pending = 0,\r\n    Resolving = 1,\r\n    Resolved = 2,\r\n    Rejected = 3\r\n}\r\n\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport const STRING_STATES: string[] = /*#__PURE__*/[\r\n    \"pending\", \"resolving\", \"resolved\", REJECTED\r\n];\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getKnownSymbol, objDefineProp, WellKnownSymbols } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\nconst toStringTagSymbol: symbol = getKnownSymbol(WellKnownSymbols.toStringTag) as typeof Symbol.toStringTag;\r\n\r\n/**\r\n * The PolyPromiseConstructor interface represents the constructor for the polyfill Promise object.\r\n * @since 0.5.0\r\n * @group Polyfill\r\n */\r\nexport interface PolyPromiseConstructor {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    new <T>(executor: PromiseExecutor<T>): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n     * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n     * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n     * and will reject with this first rejection message / error.\r\n     * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns\r\n     * <ul>\r\n     * <li> An already resolved `Promise`, if the input passed is empty.\r\n     * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n     * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n     * promises reject.\r\n     * </ul>\r\n     */\r\n    all<T>(input: Iterable<PromiseLike<T>>, timeout?: number): IPromise<T[]>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n     * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n     * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param reason - The rejection reason\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A rejected promise.\r\n     */\r\n    reject<T = never>(reason?: any, timeout?: number): IPromise<T>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve(): IPromise<void>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve<T>(value: T | PromiseLike<T>, timeout?: number): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T extends readonly unknown[] | []>(values: T, timeout?: number): Promise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n}\r\n\r\n/**\r\n * A full polyfill for the Promise class.\r\n * Represents the completion of an asynchronous operation, and its resulting value.\r\n * @since 0.5.0\r\n * @class\r\n * @group Polyfill\r\n * @group Promise\r\n */\r\nexport let PolyPromise = /*#__PURE__*/(function () {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    function PolyPromiseImpl<T>(executor: PromiseExecutor<T>) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function() {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     */\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.any = createAsyncAnyPromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\r\n    let theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved: any, onRejected: any) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected: any) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally: any) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl as unknown as PolyPromiseConstructor;\r\n}());"],"names":["_pureAssign","func1","func2","_pureRef","value","name","safe","func","argArray","v","apply","this","e","_createIs","theType","isUndefined","UNDEFINED","isDefined","arg","UNDEF_VALUE","isPromiseLike","then","isFunction","polyObjHasOwn","obj","prop","ObjProto","hasOwnProperty","CALL","objGetOwnPropertyDescriptor","objForEachKey","theObject","callbackfn","NULL_VALUE","OBJECT","objHasOwn","objDefine","target","key","propDesc","objDefineProp","propMap","l","get","desc","set","newValue","_assignMapValue","theMap","writable","enumerable","dumpObj","object","format","propertyValueDump","EMPTY","objType","TO_STRING","ERROR_TYPE","stack","asString","message","JSON","stringify","replace","throwTypeError","TypeError","_doNothing","_getProto","__PROTO__","createEnumKeyMap","values","completeFn","objFreeze","_getGlobalValue","result","globalThis","self","window","global","_initTestHooks","gbl","_globalCfg","GLOBAL_CONFIG_KEY","_globalLazyTestHooks","createCachedValue","toJSON","_getGlobalInstFn","getFn","theArgs","cachedValue","lzy","getGlobal","useCached","_cachedGlobal","getInst","WINDOW","_initSymbol","_symbol","SYMBOL","getSymbol","getKnownSymbol","description","knownName","_wellKnownSymbolMap","sym","_wellKnownSymbolCache","theSymbol","toString","POLYFILL_TAG","isIterator","next","isIterable","iterForOf","iter","thisArg","_iterSymbol","err","iterResult","count","done","failed","throw","return","fnApply","fn","arrForEach","theArray","len","LENGTH","idx","arrSlice","ArrSlice","arguments","polyObjCreate","type","FUNCTION","tempFunc","PROTOTYPE","objSetPrototypeOf","proto","ObjClass","d","b","_isProtoArray","_a","Array","_setName","baseClass","NAME","scheduleTimeout","overrideFn","isArr","isArray","length","setFn","setTimeout","clearFn","clearTimeout","timerFn","handler","dn","cancelFn","timerId","ref","refreshFn","refresh","theTimerHandler","cancel","_cancel","_refresh","HAS_REF","REF","UNREF","_unref","h","ENABLED","doAwaitResponse","cb","doAwait","status","rejected","reason","REJECTED","resolveFn","rejectFn","_hasInitEventFn","doc","evt","createEvent","initEvent","dumpFnObj","_createAggregationError","_aggregationError","orgName","theBaseClass","Error","captureFn","captureStackTrace","_this","orgProto","_self","objGetPrototypeOf","CONSTRUCTOR","constructCb","c","args","errors","objCreate","__","_createAllPromise","newPromise","input","additionalArgs","resolve","reject","values_1","pending_1","item","_createResolvedPromise","_createRejectedPromise","_resolve","createAsyncPromise","executor","timeout","processor","_settledValue","_thePromise","_state","_hasResolved","_queue","_id","_uniquePromiseId","_handled","_unHandledRejectionHandler","_then","onResolved","onRejected","_currentPromiseId","push","_processQueue","pop","_strState","STRING_STATES","pending","slice","_createSettleIfFn","newState","allowState","theValue","_notifyUnhandledRejection","evtName","theConsole","theEvt","isNode","process","emit","NODE_UNHANDLED_REJECTION","getWindow","populateEvent","g","useNewEvent","_hasPromiseRejectionEvent","STR_PROMISE","getDocument","_hasInitEvent","Event","DISPATCH_EVENT","catch","undefined","finally","onFinally","thenFinally","catchFinally","_rejectFn","call","callbackTimeout","isNumber","createAsyncAllSettledPromise","_allAsyncSettledCreator","processItem","createAsyncRacePromise","_raceAsyncCreator","isDone","createAsyncAnyPromise","_anyAsyncCreator","theErros","PromiseClass_1","Object","ArrCls","w","s","String","asyncIterator","hasInstance","isConcatSpreadable","iterator","match","matchAll","search","species","split","toPrimitive","toStringTag","unscopables","versions","node","createAsyncAllPromise","createAsyncResolvedPromise","createAsyncRejectedPromise","toStringTagSymbol","PolyPromise","PolyPromiseImpl","_$","state","all","race","any","allSettled","theProto","prototype","onfinally","Promise","resolved"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,33,36,37,38]}