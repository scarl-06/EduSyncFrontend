{"version":3,"file":"ts-async.js","sources":["https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/constants.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/await.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/treeshake_helpers.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/debug.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/state.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/event.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/base.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/itemProcessor.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/asyncPromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/nativePromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/syncPromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/idlePromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/promise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/timeoutPromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/helpers/doWhileAsync.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/helpers/arrForEachAsync.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/helpers/iterForOfAsync.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/scheduler/taskScheduler.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/polyfills/promise.ts"],"sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nexport const STR_PROMISE = \"Promise\";\r\nexport const DONE = \"done\";\r\nexport const VALUE = \"value\";\r\nexport const ITERATOR = \"iterator\";\r\nexport const RETURN = \"return\";\r\nexport const REJECTED = \"rejected\";","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { AwaitResponse } from \"../interfaces/await-response\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { FinallyPromiseHandler, RejectedPromiseHandler, ResolvedPromiseHandler } from \"../interfaces/types\";\r\nimport { REJECTED } from \"../internal/constants\";\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | Promise<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | Promise<T | TResult1 | TResult2>): T | TResult1 | TResult2 | Promise<T | TResult1 | TResult2>;\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | PromiseLike<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | PromiseLike<T | TResult1 | TResult2>): T | TResult1 | TResult2 | PromiseLike<T | TResult1 | TResult2>;\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait to be resolved or rejected.\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | IPromise<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2>): T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2> {\r\n    return doAwait(value as T, (value) => {\r\n        return cb ? cb({\r\n            status: \"fulfilled\",\r\n            rejected: false,\r\n            value: value\r\n        }) : value;\r\n    },\r\n    (reason) => {\r\n        return cb ? cb({\r\n            status: REJECTED,\r\n            rejected: true,\r\n            reason: reason\r\n        }) : reason;\r\n    });\r\n}\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | Promise<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | Promise<TResult1 | TResult2>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | PromiseLike<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | PromiseLike<TResult1 | TResult2>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | IPromise<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | IPromise<TResult1 | TResult2> {\r\n    let result: T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2> | PromiseLike<TResult1 | TResult2> = value;\r\n    \r\n    try {\r\n        if (isPromiseLike<T>(value)) {\r\n            if (resolveFn || rejectFn) {\r\n                result = value.then(resolveFn, rejectFn) as any;\r\n            }\r\n        } else {\r\n            try {\r\n                if (resolveFn) {\r\n                    result = resolveFn(value);\r\n                }\r\n            } catch (err) {\r\n                if (rejectFn) {\r\n                    result = rejectFn(err);\r\n                } else {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (finallyFn) {\r\n            doFinally(result as any, finallyFn);\r\n        }\r\n    }\r\n\r\n    return result as any;\r\n}\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | Promise<T>, finallyFn: FinallyPromiseHandler): T | Promise<T>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | PromiseLike<T>, finallyFn: FinallyPromiseHandler): T | PromiseLike<T>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | IPromise<T>, finallyFn: FinallyPromiseHandler): T | IPromise<T> {\r\n    let result = value;\r\n    if (finallyFn) {\r\n        if (isPromiseLike<T>(value)) {\r\n            if ((value as IPromise<T>).finally) {\r\n                result = (value as IPromise<T>).finally(finallyFn);\r\n            } else {\r\n                // Simulate finally if not available\r\n                result = value.then(\r\n                    function(value) {\r\n                        finallyFn();\r\n                        return value;\r\n                    }, function(reason: any) {\r\n                        finallyFn();\r\n                        throw reason;\r\n                    });\r\n            }\r\n        } else {\r\n            finallyFn();\r\n        }\r\n    }\r\n\r\n    return result;\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal tree shaking helper to return the first available function from the two provided.\r\n * This is required to ensure that tree-shaking can remove any unused functions as this ensures\r\n * that the alias assignments are not considered side-effects and are tagged correctly as pure.\r\n * @param func1 - The system function to use if available\r\n * @param func2 - The polyfill function to use if the static function is not available\r\n * @returns The first available function from the two provided\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _pureAssign<F>(func1: F, func2?: F): F {\r\n    return func1 || func2;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal tree shaking helper to return the value of the named property from the provided object.\r\n * By using this helper, we can explicitly tell the tree-shaking tools that this function is pure and\r\n * has no side effects. As some tree-shaking tools may not be able to determine this automatically.\r\n * @param value - The object to get the property value from\r\n * @param name - The name of the property to get the value of\r\n * @returns The value of the named property from the provided object\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _pureRef<R extends T[keyof T], T = any>(value: T, name: keyof T): R {\r\n    return value[name] as R;\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { objDefineProperties } from \"@nevware21/ts-utils\";\r\nimport { _pureAssign } from \"../internal/treeshake_helpers\";\r\n\r\nlet _debugState: any;\r\nlet _debugResult: any;\r\nlet _debugHandled: any;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nexport let _promiseDebugEnabled = false;\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) let _theLogger: (id: string, message: string) => void = null;\r\n//#endif\r\n\r\n/**\r\n * @internal\r\n * @ignore Internal function enable logging the internal state of the promise during execution, this code and references are\r\n * removed from the production artifacts\r\n */\r\nexport const _debugLog = (/*#__PURE__*/_pureAssign((id: string, message: string) => {\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) if (_theLogger) {\r\n    //#:(!DEBUG)     _theLogger(id, message);\r\n    //#:(!DEBUG) }\r\n    //#endif\r\n}));\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function to add the debug state to the promise so that it provides simular visibility as you would\r\n * see from native promises\r\n * @param thePromise - The Promise implementation\r\n * @param stateFn - The function to return the state of the promise\r\n * @param resultFn - The function to return the result (settled value) of the promise\r\n * @param handledFn - The function to return whether the promise has been handled (used for throwing\r\n * unhandled rejection events)\r\n */\r\nexport function _addDebugState(thePromise: any, stateFn: () => string, resultFn: () => string, handledFn: () => boolean) {\r\n    // While the IPromise implementations provide a `state` property, keeping the `[[PromiseState]]`\r\n    // as native promises also have a non-enumerable property of the same name\r\n    _debugState = _debugState || { toString: () => \"[[PromiseState]]\" };\r\n    _debugResult = _debugResult || { toString: () => \"[[PromiseResult]]\" };\r\n    _debugHandled = _debugHandled || { toString: () => \"[[PromiseIsHandled]]\" };\r\n    \r\n    let props: PropertyDescriptorMap = {};\r\n    props[_debugState] = { get: stateFn };\r\n    props[_debugResult] = { get: resultFn };\r\n    props[_debugHandled] = { get: handledFn };\r\n\r\n    objDefineProperties(thePromise, props);\r\n}\r\n\r\n/**\r\n * Debug helper to enable internal debugging of the promise implementations. Disabled by default.\r\n * For the generated packages included in the npm package the `logger` will not be called as the\r\n * `_debugLog` function that uses this logger is removed during packaging.\r\n *\r\n * It is available directly from the repository for unit testing.\r\n *\r\n * @group Debug\r\n * @param enabled - Should debugging be enabled (defaults `false`, when `true` promises will have\r\n * additional debug properties and the `toString` will include extra details.\r\n * @param logger - Optional logger that will log internal state changes, only called in debug\r\n * builds as the calling function is removed is the production artifacts.\r\n * @example\r\n * ```ts\r\n * // The Id is the id of the promise\r\n * // The message is the internal debug message\r\n * function promiseDebugLogger(id: string, message: string) {\r\n *     if (console && console.log) {\r\n *         console.log(id, message);\r\n *     }\r\n * }\r\n *\r\n * setPromiseDebugState(true, promiseDebugLogger);\r\n *\r\n * // While the logger will not be called for the production packages\r\n * // Setting the `enabled` flag to tru will cause each promise to have\r\n * // the following additional properties added\r\n * // [[PromiseState]]; => Same as the `state` property\r\n * // [[PromiseResult]]; => The settled value\r\n * // [[PromiseIsHandled]] => Identifies if the promise has been handled\r\n * // It will also cause the `toString` for the promise to include additional\r\n * // debugging information\r\n * ```\r\n */\r\nexport function setPromiseDebugState(enabled: boolean, logger?: (id: string, message: string) => void) {\r\n    _promiseDebugEnabled = enabled;\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _theLogger = logger;\r\n    //#endif\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { REJECTED } from \"./constants\";\r\n\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport const enum ePromiseState {\r\n    Pending = 0,\r\n    Resolving = 1,\r\n    Resolved = 2,\r\n    Rejected = 3\r\n}\r\n\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport const STRING_STATES: string[] = /*#__PURE__*/[\r\n    \"pending\", \"resolving\", \"resolved\", REJECTED\r\n];\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { dumpObj, getDocument, getInst, ICachedValue, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\n\r\nconst DISPATCH_EVENT = \"dispatchEvent\";\r\nlet _hasInitEvent: ICachedValue<boolean>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to determine if the document has the `initEvent` function\r\n * @param doc - The document to check\r\n * @returns\r\n */\r\nfunction _hasInitEventFn(doc: Document) {\r\n    let evt: any;\r\n    if (doc && doc.createEvent) {\r\n        evt = doc.createEvent(\"Event\");\r\n    }\r\n    \r\n    return (!!evt && evt.initEvent);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param target\r\n * @param evtName\r\n * @param populateEvent\r\n * @param useNewEvent\r\n */\r\nexport function emitEvent(target: any, evtName: string, populateEvent: (theEvt: Event | any) => Event | any, useNewEvent: boolean) {\r\n\r\n    let doc = getDocument();\r\n    !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [ doc ]).v));\r\n\r\n    let theEvt: Event = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {} as Event);\r\n    populateEvent && populateEvent(theEvt);\r\n\r\n    if (_hasInitEvent.v) {\r\n        theEvt.initEvent(evtName, false, true);\r\n    }\r\n\r\n    if (theEvt && target[DISPATCH_EVENT]) {\r\n        target[DISPATCH_EVENT](theEvt);\r\n    } else {\r\n        let handler = target[\"on\" + evtName];\r\n        if (handler) {\r\n            handler(theEvt);\r\n        } else {\r\n            let theConsole = getInst(\"console\");\r\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\r\n        }\r\n    }\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined,\r\n    throwTypeError, WellKnownSymbols, objToString, scheduleTimeout, ITimerHandler, getWindow, isNode,\r\n    getGlobal, objDefine, objDefineProp, iterForOf, isIterable, isArray, arrForEach, createCachedValue,\r\n    ICachedValue, safe, getInst, createCustomError\r\n} from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromisePendingProcessor } from \"./itemProcessor\";\r\nimport {\r\n    FinallyPromiseHandler, PromiseCreatorFn, PromiseExecutor, RejectedPromiseHandler, ResolvedPromiseHandler\r\n} from \"../interfaces/types\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { REJECTED, STR_PROMISE } from \"../internal/constants\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"./debug\";\r\n//#endif\r\n\r\nconst NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nconst UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\n\r\nlet _currentPromiseId: number[] = [];\r\nlet _uniquePromiseId = 0;\r\nlet _unhandledRejectionTimeout = 10;\r\nlet _aggregationError: ICachedValue<any>;\r\n\r\n/**\r\n * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent)\r\n */\r\ninterface _PromiseRejectionEvent extends Event {\r\n    /**\r\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/promise)\r\n     */\r\n    readonly promise: IPromise<any>;\r\n\r\n    /**\r\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/reason)\r\n     */\r\n    readonly reason: any;\r\n}\r\n\r\nlet _hasPromiseRejectionEvent: ICachedValue<_PromiseRejectionEvent>;\r\n\r\nfunction dumpFnObj(value: any) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n\r\n    return dumpObj(value);\r\n}\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) function _getCaller(prefix: string, start: number) {\r\n//#:(!DEBUG)     let stack = new Error().stack;\r\n//#:(!DEBUG)     if (stack) {\r\n//#:(!DEBUG)         let lines = stack.split(\"\\n\");\r\n//#:(!DEBUG)         if (lines.length > start) {\r\n//#:(!DEBUG)             return prefix + \":\" + arrSlice(lines, start, start + 5).join(\"\\n\") + \"\\n...\";\r\n//#:(!DEBUG)         }\r\n//#:(!DEBUG)     }\r\n//#:(!DEBUG)     return null;\r\n//#:(!DEBUG) }\r\n//#endif\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createAggregationError(values: any[]) {\r\n    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", (self, args) => {\r\n        self.errors = args[0];\r\n    })));\r\n\r\n    return new _aggregationError.v(values);\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>, ...additionalArgs: any): IPromise<T>;\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>): IPromise<T> {\r\n    let additionalArgs = arrSlice(arguments, 3);\r\n    let _state = ePromiseState.Pending;\r\n    let _hasResolved = false;\r\n    let _settledValue: T;\r\n    let _queue: (() => void)[] = [];\r\n    let _id = _uniquePromiseId++;\r\n    let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    let _handled = false;\r\n    let _unHandledRejectionHandler: ITimerHandler = null;\r\n    let _thePromise: IPromise<T>;\r\n    \r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    function _then<TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): IPromise<TResult1 | TResult2> {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n\r\n            let thenPromise = newPromise<TResult1, TResult2>(function (resolve, reject) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _getCaller(\"_then\", 7));\r\n                //#endif\r\n\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        let handler = _state === ePromiseState.Resolved ? onResolved : onRejected;\r\n                        let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n    \r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve as any, reject);\r\n                        } else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value as any);\r\n                        } else if (_state === ePromiseState.Rejected) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        } else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value as any);\r\n                        }\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n    \r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n    \r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n    \r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n    \r\n            return thenPromise;\r\n    \r\n        } finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    function _catch<TResult1 = T>(onRejected: RejectedPromiseHandler<TResult1>) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    function _finally<TResult1 = T, TResult2 = never>(onFinally: FinallyPromiseHandler): IPromise<TResult1 | TResult2> {\r\n        let thenFinally: any = onFinally;\r\n        let catchFinally: any = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function(value: TResult1 | TResult2) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            }\r\n    \r\n            catchFinally = function(reason: any) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            }\r\n        }\r\n\r\n        return _then<TResult1, TResult2>(thenFinally as any, catchFinally as any);\r\n    }\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    function _processQueue() {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            let pending = _queue.slice();\r\n            _queue = [];\r\n\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    function _createSettleIfFn(newState: ePromiseState, allowState: ePromiseState) {\r\n        return (theValue: T) => {\r\n            if (_state === allowState) {\r\n                if (newState === ePromiseState.Resolved && isPromiseLike(theValue)) {\r\n                    _state = ePromiseState.Resolving;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(\r\n                        _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Resolving),\r\n                        _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Resolving));\r\n                    return;\r\n                }\r\n\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === ePromiseState.Rejected && !_unHandledRejectionHandler) {\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Setting up unhandled rejection\");\r\n                    //#endif\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout)\r\n                }\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n\r\n    function _notifyUnhandledRejection() {\r\n        if (!_handled) {\r\n            // Mark as handled so we don't keep notifying\r\n            _handled = true;\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            } else {\r\n                let gbl = getWindow() || getGlobal();\r\n    \r\n                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe(getInst<_PromiseRejectionEvent>, [STR_PROMISE + \"RejectionEvent\"]).v));\r\n\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, (theEvt: any) => {\r\n                    objDefine(theEvt, \"promise\", { g: () => _thePromise });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    } as any;\r\n\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);\r\n    }\r\n\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol<symbol>(WellKnownSymbols.toStringTag)] = \"IPromise\";\r\n    }\r\n\r\n    let createStack: string;\r\n    //#if DEBUG\r\n    //#:(!{DEBUG}) createStack = _getCaller(\"Created\", 5);\r\n    //#endif\r\n    function _toString() {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (createStack ? \" @ \" + createStack : \"\");\r\n    }\r\n\r\n    _thePromise.toString = _toString;\r\n\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n\r\n        const _rejectFn = _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Pending);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(\r\n                _thePromise,\r\n                _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Pending),\r\n                _rejectFn);\r\n        } catch (e) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Exception thrown: \" + dumpFnObj(e));\r\n            //#endif\r\n            _rejectFn(e);\r\n        }\r\n\r\n        //#ifdef DEBUG\r\n        //#:(!DEBUG) _debugLog(_toString(), \"~Executing\");\r\n        //#endif\r\n    })();\r\n\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllPromise(newPromise: PromiseCreatorFn): <T>(input: Iterable<T | PromiseLike<T>>, ...additionalArgs: any) => IPromise<Awaited<T>[]> {\r\n    return function <T>(input: Iterable<T | PromiseLike<T>>): IPromise<Awaited<T>[]> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T>[]>((resolve, reject) => {\r\n            try {\r\n                let values = [] as any;\r\n                let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n                iterForOf(input, (item, idx) => {\r\n                    if (item) {\r\n                        pending++;\r\n                        doAwait(item, (value) => {\r\n                            // Set the result values\r\n                            values[idx] = value;\r\n                            if (--pending === 0) {\r\n                                resolve(values);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value - Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createResolvedPromise(newPromise: PromiseCreatorFn): <T>(value: T, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(value: T): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike<T>(value)) {\r\n            return value as unknown as IPromise<T>;\r\n        }\r\n    \r\n        return newPromise((resolve) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Resolving Promise\");\r\n            //#endif\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRejectedPromise(newPromise: PromiseCreatorFn): <T>(reason: any, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(reason: any): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise((_resolve, reject) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Rejecting Promise\");\r\n            //#endif\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function which when called will return a new Promise object that resolves to an array of\r\n * IPromiseResults from the input promises. The returned promise will resolve when all of the inputs'\r\n * promises have resolved or rejected, or if the input contains no promises. It will resolve only after\r\n * all input promises have been fulfilled (resolve or rejected).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllSettledPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>> {\r\n    return createCachedValue(function <T>(input: T, ..._args: any[]): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>((resolve, reject) => {\r\n            let values: { -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; } = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value) => {\r\n                    if (value.rejected) {\r\n                        values[idx] = {\r\n                            status: REJECTED,\r\n                            reason: value.reason\r\n                        };\r\n                    } else {\r\n                        values[idx] = {\r\n                            status: \"fulfilled\",\r\n                            value: value.value\r\n                        };\r\n                    }\r\n                \r\n                    if (--pending === 0) {\r\n                        resolve(values);\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise settles with the eventual state of the first promise that settles.\r\n * @description The returned promise is one of the promise concurrency methods. It's useful when you want\r\n * the first async task to complete, but do not care about its eventual state (i.e. it can either succeed\r\n * or fail).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the first promise to settle is fulfilled,\r\n * and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises,\r\n * the returned promise is still settled.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createRacePromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let isDone = false;\r\n\r\n            function processItem(item: any) {\r\n                doAwaitResponse(item, (value) => {\r\n                    if (!isDone) {\r\n                        isDone = true;\r\n                        if (value.rejected) {\r\n                            reject(value.reason);\r\n                        } else {\r\n                            resolve(value.value);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment\r\n * value. It rejects when all of the input's promises reject (including when an empty iterable is passed),\r\n * with an AggregateError containing an array of rejection reasons.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the any of the input's promises fulfills,\r\n * with this first fulfillment value. It rejects when all of the input's promises reject (including when\r\n * an empty iterable is passed), with an AggregateError containing an array of rejection reasons.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createAnyPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let theErros: Array<any> = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n            let isDone = false;\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value ) => {\r\n                    if (!value.rejected) {\r\n                        isDone = true;\r\n                        resolve(value.value);\r\n                        return;\r\n                    } else {\r\n                        theErros[idx] = value.reason;\r\n                    }\r\n\r\n                    if (--pending === 0 && !isDone) {\r\n                        reject(_createAggregationError(theErros));\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0 && !isDone) {\r\n                    // All promises were either resolved or where not a promise\r\n                    reject(_createAggregationError(theErros));\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\n\r\nexport type PromisePendingProcessor = (pending: PromisePendingFn[]) => void;\r\nexport type PromisePendingFn = () => void;\r\nexport type PromiseCreatorFn = <T, TResult2 = never>(newExecutor: PromiseExecutor<T>, ...extraArgs: any) => IPromise<T | TResult2>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor(pending: PromisePendingFn[]): void {\r\n    arrForEach(pending, (fn: PromisePendingFn) => {\r\n        try {\r\n            fn();\r\n        } catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleTimeout(() => {\r\n            syncItemProcessor(pending);\r\n        }, callbackTimeout);\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let options: any;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleIdleCallback((deadline: IdleDeadline) => {\r\n            syncItemProcessor(pending);\r\n        }, options);\r\n    };\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise,\r\n    _createRejectedPromise, _createResolvedPromise\r\n} from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { timeoutItemProcessor } from \"./itemProcessor\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\nimport { ICachedValue } from \"@nevware21/ts-utils\";\r\n\r\nlet _allAsyncSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceAsyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anyAsyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Creates an asynchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the optional provided timeout value to schedule when the chained items will be ececuted.\r\n * @group Async\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createAsyncPromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T> {\r\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createAsyncAllPromise: <T>(input: Iterable<PromiseLike<T>>, timeout?: number) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createAsyncResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createAsyncRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\r\n    return _allAsyncSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function createAsyncRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function  createAsyncRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\r\n    return _raceAsyncCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createAsyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\r\n    return _anyAsyncCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { createAsyncPromise } from \"./asyncPromise\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { dumpObj, isFunction, objDefineProp, throwTypeError, getInst, ICachedValue, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Flag to determine if the native Promise class should be used if available, used for testing purposes.\r\n */\r\nlet _useNative: boolean = true;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the native Promise class\r\n */\r\nlet _promiseCls: ICachedValue<PromiseConstructor>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.all` method\r\n */\r\nlet _allCreator: ICachedValue<<T>(input: Iterable<T | PromiseLike<T>>, ...additionalArgs: any) => IPromise<Awaited<T>[]>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.allSettled` method\r\n */\r\nlet _allNativeSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.race` method\r\n */\r\nlet _raceNativeCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.any` method\r\n */\r\nlet _anyNativeCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Test Hook function to clear the cached values and set whether to use the native Promise class\r\n * @param useNative - Flag to determine if the native Promise class should be used if available\r\n */\r\nexport function _clearPromiseCache(useNative: boolean) {\r\n//#ifdef _DEBUG\r\n//#:(!_DEBUG)     _useNative = !!useNative;\r\n//#:(!_DEBUG)     _promiseCls = null as any;\r\n//#:(!_DEBUG)     _allCreator = null as any;\r\n//#:(!_DEBUG)     _allNativeSettledCreator = null as any;\r\n//#:(!_DEBUG)     _raceNativeCreator = null as any;\r\n//#:(!_DEBUG)     _anyNativeCreator = null as any;\r\n//#endif\r\n}\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createNativePromiseHelper<F>(name: string, func: () => ICachedValue<F>): ICachedValue<F> {\r\n    !_promiseCls && (_promiseCls = createCachedValue<PromiseConstructor>((_useNative && safe(getInst, [STR_PROMISE]).v) || null as any));\r\n    if (_promiseCls.v && _promiseCls.v[name]) {\r\n        return createCachedValue(function<T extends readonly unknown[] | []>(input: T, timeout?: number) {\r\n            return createNativePromise((resolve, reject) => {\r\n                _promiseCls.v[name](input).then(resolve, reject);\r\n            });\r\n        } as F);\r\n    }\r\n    \r\n    return func();\r\n}\r\n\r\n/**\r\n * Creates a Promise instance that when resolved or rejected will execute it's pending chained operations using the\r\n * available native Promise implementation.\r\n * If runtime does not support native `Promise` class (or no polyfill is available) this function will fallback to using\r\n * `createAsyncPromise` which will resolve them __asynchronously__ using the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * @group Alias\r\n * @group Promise\r\n * @group Native\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createNativePromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T> {\r\n    !_promiseCls && (_promiseCls = createCachedValue<PromiseConstructor>((_useNative && safe(getInst, [STR_PROMISE]).v) || null as any));\r\n    const PrmCls = _promiseCls.v;\r\n    if (!PrmCls) {\r\n        return createAsyncPromise(executor);\r\n    }\r\n\r\n    if (!isFunction(executor)) {\r\n        throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\r\n    }\r\n\r\n    let _state = ePromiseState.Pending;\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    let thePromise = new PrmCls<T>((resolve, reject) => {\r\n        function _resolve(value: T) {\r\n            _state = ePromiseState.Resolved;\r\n            resolve(value);\r\n        }\r\n\r\n        function _reject(reason: any) {\r\n            _state = ePromiseState.Rejected;\r\n            reject(reason);\r\n        }\r\n\r\n        executor(_resolve, _reject);\r\n\r\n    }) as IPromise<T>;\r\n\r\n    objDefineProp(thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    return thePromise;\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @group Native\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport function createNativeAllPromise<T>(input: Iterable<PromiseLike<T>>, timeout?: number): IPromise<T[]> {\r\n    !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", () => createCachedValue(_createAllPromise(createNativePromise))));\r\n    return _allCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @group Native\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeResolvedPromise: <T>(value: T, timeout?: number) => Promise<T> =  /*#__PURE__*/_createResolvedPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @group Native\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeRejectedPromise: <T = unknown>(reason: any, timeout?: number) => Promise<T> = /*#__PURE__*/_createRejectedPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise | native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise | native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", () => _createAllSettledPromise(createNativePromise)));\r\n    return _allNativeSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function createNativeRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function  createNativeRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", () => _createRacePromise(createNativePromise)));\r\n    return _raceNativeCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createNativeAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createNativeAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", () => _createAnyPromise(createNativePromise)));\r\n    return _anyNativeCreator.v(values, timeout);\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise,\r\n    _createRejectedPromise, _createResolvedPromise\r\n} from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { syncItemProcessor } from \"./itemProcessor\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\nimport { ICachedValue } from \"@nevware21/ts-utils\";\r\n\r\nlet _allSyncSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceSyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anySyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Creates a synchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __synchronously__ in the same execution cycle as the operation that calls the `executors`, `resolve` or `reject` functions.\r\n *\r\n * @group Synchronous\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n */\r\nexport function createSyncPromise<T>(executor: PromiseExecutor<T>): IPromise<T>  {\r\n    return _createPromise(createSyncPromise, syncItemProcessor, executor);\r\n}\r\n\r\n/**\r\n * Returns a single synchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __synchronously__ in the same\r\n * execution cycle as the final operation pending promises have resolved, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __synchronously__ at the point of\r\n * being added (eg. `then()`; `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createSyncAllPromise: <T>(input: Iterable<PromiseLike<T>>) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createSyncPromise);\r\n\r\n/**\r\n * Returns a single synchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new synchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __synchronously__ at the point of being\r\n * added (calling `then()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n */\r\nexport const createSyncResolvedPromise: <T>(value: T) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createSyncPromise);\r\n\r\n/**\r\n * Returns a single synchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __synchronously__ at the point of being added (eg. `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n */\r\nexport const createSyncRejectedPromise: <T = unknown>(reason: any) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createSyncPromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createSyncPromise | synchronous} promise implementation. Any chained operations will execute\r\n * __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createSyncAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createSyncPromise | synchronous} promise implementation. Any chained operations will execute\r\n * __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createSyncAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));\r\n    return _allSyncSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createSyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createSyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * synchronously.\r\n */\r\nexport function createSyncRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createSyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createSyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * synchronously.\r\n */\r\nexport function  createSyncRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));\r\n    return _raceSyncCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createSyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createSyncAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createSyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createSyncAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));\r\n    return _anySyncCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, isUndefined } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { idleItemProcessor } from \"./itemProcessor\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\nimport { _pureAssign } from \"../internal/treeshake_helpers\";\r\n\r\nlet _defaultIdleTimeout: number | undefined;\r\n\r\nlet _allIdleSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceIdleCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anyIdleCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport function setDefaultIdlePromiseTimeout(idleDeadline?: number | undefined) {\r\n    _defaultIdleTimeout = idleDeadline;\r\n}\r\n\r\n/**\r\n * @deprecated Use `setDefaultIdlePromiseTimeout` instead\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport const setDefaultIdleTimeout = (/*#__PURE__*/_pureAssign(setDefaultIdlePromiseTimeout));\r\n\r\n/**\r\n * Creates an idle Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed. When `requestIdleCallback` is not available this becomes the same as\r\n * `createAsyncPromise` which uses `setTimeout` to schedule executions.\r\n * @group Idle\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional deadline timeout to wait before processing the items, defaults to undefined. If the number of\r\n * milliseconds represented by this parameter has elapsed and the callback has not already been called, then a task to execute\r\n * the callback is queued in the event loop (even if doing so risks causing a negative performance impact). timeout must be a\r\n * positive value or it is ignored.\r\n */\r\nexport function createIdlePromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T>  {\r\n    let theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;\r\n    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);\r\n}\r\n\r\n/**\r\n * Returns an idle Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__\r\n * using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using\r\n * the `requestIdleCallback` API (if available) with the optional provided timeout value to schedule\r\n * when the chained items will be executed. (eg. `then()`; `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional deadline timeout to wait before processing the items, defaults to undefined. If the number of\r\n * milliseconds represented by this parameter has elapsed and the callback has not already been called, then a task to execute\r\n * the callback is queued in the event loop (even if doing so risks causing a negative performance impact). timeout must be a\r\n * positive value or it is ignored.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createIdleAllPromise: <T>(input: Iterable<PromiseLike<T>>, timeout?: number) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createIdlePromise);\r\n\r\n/**\r\n * Returns an idle Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the\r\n * `requestIdleCallback` API (if available) with the optional provided timeout value to schedule when\r\n * the chained items will be executed. (eg. `then()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createIdleResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createIdlePromise);\r\n\r\n/**\r\n * Returns an idle Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the o`requestIdleCallback` API\r\n * (if available) with the optional provided timeout value to schedule when the chained items will\r\n * be executed. (eg. `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createIdleRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createIdlePromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createIdlePromise | idle} promise implementation. Any chained operations will execute\r\n * __asynchronously__ when the environment is idle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createIdleAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createIdlePromise | idle} promise implementation. Any chained operations will execute\r\n * __asynchronously__ when the environment is idle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createIdleAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));\r\n    return _allIdleSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createIdleRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createIdleRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously when the system detects that the runtime is idle.\r\n */\r\nexport function createIdleRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createIdleRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createIdleRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously when the system detects that the runtime is idle.\r\n */\r\nexport function createIdleRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));\r\n    return _raceIdleCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createIdleAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createIdleAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createIdleAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createIdleAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));\r\n    return _anyIdleCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { createCachedValue, ICachedValue } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createNativePromise } from \"./nativePromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\nlet _promiseCreator: ICachedValue<<T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>>;\r\nlet _allSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anyCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Set the default promise implementation to use when calling `createPromise`; `createAllPromise`; `createResolvedPromise`\r\n * and `createRejectedPromise`. This is effective a global value and changing this will affect ALL callers of these\r\n * functions, as such these functions should only be used when switching implementations would have not unexpected\r\n * consequences like switching from a `createSyncPromise` to `createIdlePromise` where idle promises have a possibility\r\n * of never getting called during application shutdown or during an expected timeframe.\r\n * @group Alias\r\n * @group Promise\r\n * @param creator - The creator function to call when a new promise is required.\r\n */\r\nexport function setCreatePromiseImpl(\r\n    creator: <T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>\r\n) {\r\n    _promiseCreator = creator ? createCachedValue(creator) : null;\r\n}\r\n\r\n/**\r\n * Creates a Promise instance using the current default promise creator that when resolved or rejected will execute\r\n * it's pending chained operations.\r\n * @group Alias\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - [Optional] timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createPromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T>  {\r\n    !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));\r\n\r\n    return _promiseCreator.v.call(this, executor, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createAllPromise: <T>(input: Iterable<PromiseLike<T>>, timeout?: number) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createPromise);\r\n\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createPromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the current\r\n * promise implementation. If the current implementation is synchronous then the chained operations will\r\n * execute __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. If the current implementation is asynchronous then the chained\r\n * operations will execute __asynchronously__ using the optional provided timeout value to schedule when the\r\n * chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the current\r\n * promise implementation. If the current implementation is synchronous then the chained operations will\r\n * execute __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. If the current implementation is asynchronous then the chained\r\n * operations will execute __asynchronously__ using the optional provided timeout value to schedule when the\r\n * chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));\r\n    return _allSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * based on the current promise implementation.\r\n */\r\nexport function createRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * based on the current promise implementation.\r\n */\r\nexport function  createRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));\r\n    return _raceCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));\r\n    return _anyCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isUndefined, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createPromise } from \"./promise\";\r\n\r\n/**\r\n * Creates a Promise instance that resolve or reject after the specified timeout.\r\n * @since 0.5.0\r\n * @group Timeout\r\n * @group Promise\r\n * @param timeout - The timeout in milliseconds to wait before resolving or rejecting the promise.\r\n * @param resolveReject - [Optional] If true the promise will resolve, otherwise it will reject.\r\n * @param message - [Optional] The message to use when rejecting the promise, if not supplied (or\r\n * undefined) the default message will be used.\r\n * @returns A promise that will resolve or reject after the specified timeout.\r\n * @example\r\n * ```ts\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100);\r\n * // Throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100, false);\r\n * // throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, false, \"Hello\");\r\n * // throws an Error: Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, true, \"Hello\");\r\n * console.log(result); // Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, true, \"Hello\"), (result) => {\r\n *  console.log(result); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   // Not called\r\n * }, (err) => {\r\n *   console.log(err); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwaitResult(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   console.log(result.rejected); // true\r\n *   console.log(result.reason); // Hello\r\n * });\r\n * ```\r\n */\r\nexport function createTimeoutPromise<T = any>(timeout: number, resolveReject?: boolean, message?: T): IPromise<T> {\r\n    return createPromise((resolve, reject) => {\r\n        scheduleTimeout(() => {\r\n            (resolveReject ? resolve : reject)(!isUndefined(message) ? message : \"Timeout of \" + timeout + \"ms exceeded\" as T);\r\n        }, timeout);\r\n    });\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isFunction, isPromiseLike, utcNow } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createPromise } from \"../promise/promise\";\r\nimport { doAwait } from \"../promise/await\";\r\nimport { RejectPromiseHandler, ResolvePromiseHandler } from \"../interfaces/types\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\n\r\nfunction _doneChk<T>(isDone: boolean, state: IWhileState<T>, value: T, thisArg?: any) {\r\n    let result: boolean | IPromise<boolean> = isDone;\r\n    state.res = value;\r\n    if (!result) {\r\n        if (state.isDone && isFunction(state.isDone)) {\r\n            // Handle synchronous or asynchronous isDone function\r\n            return doAwait(state.isDone.call(thisArg, state), (done) => {\r\n                state.iter++;\r\n                return !!done;\r\n            });\r\n        } else {\r\n            result = !!state.isDone;\r\n        }\r\n    }\r\n\r\n    state.iter++;\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a while loop, calling the provided `callbackFn` function until the `state.isDone`\r\n * property is set to `true` or the optional `isDOneFn` returns `true`. The callback function will\r\n * receive a single {@link IWhileState | state} argument and may return either a value or a promise,\r\n * if a promise is returned the while loop will wait until the promise is resolved before calling\r\n * the callback function again. If the callback function never returns a promise the while loop\r\n * will be executed synchronous and last value returned by the callback will be returned, if the\r\n * callback function returns a promise the while loop will be asynchronous and an {@link IPromise}\r\n * will be returned and resolved with the last value returned by the callback or rejected if the\r\n * callback promise rejects or throws an error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @typeParam T - Identifies the element type returned by the callback function.\r\n * @param callbackFn - A function that will be called until the `state.isDone` flag is set to `true`\r\n * the function will receive a single {@link IWhileState | state} argument. The callback function\r\n * may return either a value or a promise, if a promise is returned the while loop will wait\r\n * until the promise is resolved before calling the callback function again.\r\n * @param isDoneFn - An optional function that will be called after the callback function is called,\r\n * that can be used to stop the while loop. The function will receive a single {@link IWhileState | state}\r\n * argument. If the function returns `true` the while loop will stop, otherwise the while loop will continue.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function.\r\n * If thisArg is omitted, null or undefined the array will be used as the this value.\r\n * @remarks\r\n * - If an `isDoneFn` is provided the `state.isDone` property will be set to the provided value and\r\n * is accessible withing the callback function. The callbackFn may overwrite the value of the\r\n * `state.isDone` property within the callback function with a boolean value or another function that\r\n * returns a boolean value.\r\n * - The callback function is called until until the `state.isDone` property is set to `true` or if\r\n * `state.isDone` is a function until the function returns `true`.\r\n * - The callback function will receive a single {@link IWhileState | state} argument that contains\r\n * the following properties:\r\n *  - `iter` - The zero-based iteration count, which is incremented after each call to the `callbackFn`\r\n * and any `isDone` function (if provided), the `iter` property is accessible withing the callback\r\n * function and may be overwritten within the callback function.\r\n * - `res` - The last resolved result value returned by the `callbackFn` function.\r\n * - `isDone` - A boolean value or a callback function that will be called to check if the while loop\r\n * should stop, the `isDone` property is accessible withing the callback function and may be\r\n * overwritten within the callback function.\r\n * - The callback function may return either a value or a promise, if a promise is returned the while\r\n * loop will wait until the promise is resolved before calling the callback function again.\r\n * - If the callback function throws an error when executing `synchronously` the exception will\r\n * also be thrown `synchronously` otherwise the returned promise will be rejected with the error.\r\n * @example\r\n * ```ts\r\n * // Synchronous example\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     return \"Hello\";\r\n *  }\r\n * });\r\n *\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Synchronous example with isDoneFn\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     return \"Hello\";\r\n *  }\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Asynchronous examples\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   state.isDone = true;\r\n *   return createResolvedPromise(\"Darkness\");\r\n * });\r\n * console.log(result); // Darkness\r\n *\r\n * // Asynchronous example with isDoneFn\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   return createResolvedPromise(\"Darkness\");\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Darkness after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Combination Synchronous and Asynchronous example\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await\r\n * const result = await doWhileAsync(async (state) => {\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await and dynamically setting the isDone function\r\n * const result = await doWhileAsync(async (state) => {\r\n *   // dynamically set the isDone function\r\n *   if (state.idx < 10) {\r\n *     state.isDone = () => return false;\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = () => return true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n * ```\r\n */\r\nexport function doWhileAsync<T>(callbackFn: (state: IWhileState<T>) => T | IPromise<T>, isDoneFn?: (state: IWhileState<T>) => boolean | void | IPromise<boolean | void>, thisArg?: any): T | IPromise<T> {\r\n    let promise: T | IPromise<T>;\r\n    let resolve: ResolvePromiseHandler<T>;\r\n    let reject: RejectPromiseHandler | never = (reason: any) => {\r\n        isDone = true;\r\n        throw reason;\r\n    };\r\n    let isDone = false;\r\n    let state: IWhileState<T> = {\r\n        st: utcNow(),\r\n        iter: 0,\r\n        isDone: isDoneFn || false\r\n    };\r\n\r\n    if (callbackFn) {\r\n        const _createPromise = (): IPromise<T> => {\r\n            return createPromise<T>((res, rej) => {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n        };\r\n\r\n        const _handleAsyncDone = (done: boolean) => {\r\n            isDone = !!done;\r\n            if (!isDone) {\r\n                _processNext();\r\n            } else {\r\n                resolve(state.res);\r\n            }\r\n        };\r\n\r\n        const _processNext = (): T | IPromise<T> => {\r\n            // Attempt to process the next item synchronously if possible (for performance -- to reduce the number of promises created)\r\n            while (!isDone) {\r\n                try {\r\n                    let cbResult = callbackFn.call(thisArg, state);\r\n                    if (isPromiseLike(cbResult)) {\r\n                        promise = promise || _createPromise();\r\n                        doAwait(cbResult, (res) => {\r\n                            try {\r\n                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone, reject);\r\n                            } catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        }, reject);\r\n\r\n                        // Break out of synchronous loop and wait for promise to resolve\r\n                        return promise;\r\n                    } else {\r\n                        let dnRes = _doneChk(isDone, state, cbResult, thisArg);\r\n                        if (isPromiseLike(dnRes)) {\r\n                            promise = promise || _createPromise();\r\n                            doAwait(dnRes, _handleAsyncDone, reject);\r\n\r\n                            // Break out of synchronous loop and wait for promise to resolve\r\n                            return promise;\r\n                        } else {\r\n                            isDone = !!dnRes;\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                    return promise;\r\n                }\r\n            }\r\n            \r\n            if (isDone && resolve) {\r\n                resolve(state.res);\r\n            }\r\n\r\n            return promise || state.res;\r\n        };\r\n    \r\n        return _processNext();\r\n    }\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getLength } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array (or ArratLike) instance in ascending index order. It is not invoked\r\n * for index properties that have been deleted or are uninitialized. And unlike the ES6 forEach() this supports async functions and you CAN stop\r\n * or break the iteration  by returning -1 from the `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise` then the next iteration will not be\r\n * called until the promise is resolved. If the `callbackFn` returns a `Promise` that is rejected then the iteration will stop and the promise\r\n * returned by arrForEachAsync will be rejected with the same error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one\r\n * time for each element in the array.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEachAsync supports either a `synchronous` or `asynchronous` (returns a `Promise`) callback function. If the callback function returns\r\n * a `Promise` then the next iteration will not be called until the promise is resolved. If the callback function returns a `Promise` that is\r\n * rejected then the iteration will stop and the promise returned by arrForEachAsync will be rejected with the same error.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * arrForEachASync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n *\r\n * // Asynchronous examples using await\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * await arrForEachASync(items, (value, index) => { // Note: DO NOT use async here unless you use await within the function\r\n *   if (index < 5) {\r\n *     // Logs each iteration index\r\n *     // Logs each value\r\n *     console.log(value);\r\n *     // Returning a promise will cause `arrForEachAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true);\r\n *   }\r\n *\r\n *   return -1; // Stop the iteration\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * ```\r\n */\r\nexport function arrForEachAsync<T = any>(theArray: ArrayLike<T>, callbackFn: (value: T, index: number, array: T[]) => void | number | IPromise<void | number>, thisArg?: any): void | number | IPromise<void | number> {\r\n    if (theArray) {\r\n        const len = getLength(theArray);\r\n        if (len) {\r\n            const isDone = (state: IWhileState<void | number>) => {\r\n                if (state.iter >= len || state.res === -1) {\r\n                    return true;\r\n                }\r\n            };\r\n\r\n            return doWhileAsync((state) => {\r\n                const idx = state.iter;\r\n                if (idx in theArray) {\r\n                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\r\n                }\r\n            }, isDone);\r\n        }\r\n    }\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, WellKnownSymbols, createCachedValue, fnCall, getKnownSymbol, isIterator, isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\nimport { DONE, RETURN, VALUE } from \"../internal/constants\";\r\nimport { doAwait, doFinally } from \"../promise/await\";\r\n\r\nlet _iterSymbol: ICachedValue<symbol>;\r\nlet _iterAsyncSymbol: ICachedValue<symbol>;\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEachAsync}\r\n * you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elemenets to the iterator, the actual behavior will\r\n * depend on the iterator implementation.\r\n *\r\n * if the passed `iter` is both an Iterable\\<T\\> and Iterator\\<T\\> the Iterator\\<T\\> interface takes precedence. And if\r\n * an iterable and does not have a `Symbol.iterator` property then the `iter` will be used as the iterator.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise`\r\n * then the next iteration will not be called until the promise is resolved. If the `callbackFn` returns a `Promise`\r\n * that is rejected then the iteration will stop and the promise returned by iterForEachAsync will be rejected with\r\n * the same error.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols, as used\r\n * by the library. If the iterable is using a different polyFill then the `iter` MUST be an Iterator\\<T\\> and not an\r\n * Iterable\\<T\\>.\r\n * If you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOfAsync\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param iter - The iterator or iterable of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. iterForEach\r\n * calls the callbackfn function one time for each element in the iterator.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted,\r\n * null or undefined the iterator will be used as the this value.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * // using async / await\r\n * let result = await iterForOfAsync(items, async (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   await createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  })\r\n *\r\n * console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *\r\n * // using doAwait\r\n * doAwait(iterForOfAsync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   return createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  }), (result) => {\r\n *    console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *  });\r\n * ```\r\n */\r\nexport function iterForOfAsync<T = any>(iter: Iterator<T> | Iterable<T> | AsyncIterator<T> | AsyncIterable<T>, callbackFn: (value: T, count: number, iter?: Iterator<T> | AsyncIterator<T>) => void | number | IPromise<void | number>, thisArg?: any): void | number | IPromise<void | number> {\r\n    let err: { e: any };\r\n    let iterResult: IteratorResult<T>;\r\n    let theIter: AsyncIterator<T> | Iterator<T> = iter as AsyncIterator<T> | Iterator<T>;\r\n\r\n    function onFailed(failed: any): never  {\r\n        err = { e: failed };\r\n        if (theIter.throw) {\r\n            iterResult = null;\r\n            theIter.throw(err);\r\n        }\r\n\r\n        throw failed;\r\n    }\r\n\r\n    function onFinally() {\r\n        try {\r\n            if (iterResult && !iterResult[DONE]) {\r\n                theIter[RETURN] && theIter[RETURN](iterResult);\r\n            }\r\n        } finally {\r\n            if (err) {\r\n                // eslint-disable-next-line no-unsafe-finally\r\n                throw err.e;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            // Get the asyncIterator from the iterable\r\n            !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.asyncIterator)));\r\n            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\r\n            if (!theIter) {\r\n                // Get the iterator from the iterable\r\n                !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.iterator)));\r\n                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\r\n            }\r\n        }\r\n        \r\n        if (theIter && isIterator(theIter)) {\r\n\r\n            let result: void | number | IPromise<void | number>;\r\n            try {\r\n                result = doWhileAsync((state) => {\r\n                    return doAwait(theIter.next(), (res) => {\r\n                        iterResult = res;\r\n                        if (!res[DONE]) {\r\n                            return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\r\n                        }\r\n                    }, (reason) => {\r\n                        state.isDone = true;\r\n                        onFailed(reason);\r\n                    });\r\n                }, (state: IWhileState<void | number>) => {\r\n                    if (!iterResult || iterResult[DONE] || state.res === -1) {\r\n                        onFinally();\r\n                        return true;\r\n                    }\r\n                }, thisArg || theIter);\r\n\r\n                if (isPromiseLike(result)) {\r\n                    result = doFinally(result.catch(onFailed), onFinally);\r\n                }\r\n\r\n                return result;\r\n            } catch (failed) {\r\n                onFailed(failed);\r\n            } finally {\r\n                if (result && !isPromiseLike(result)) {\r\n                    onFinally();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach, arrIndexOf, createCustomError, CustomErrorConstructor, getLength, isPromiseLike, ITimerHandler, objDefine, objDefineProp, scheduleTimeout, utcNow } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"../promise/await\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor, RejectPromiseHandler, ResolvePromiseHandler,StartQueuedTaskFn } from \"../interfaces/types\";\r\nimport { ITaskDetail } from \"../internal/ITaskDetail\";\r\nimport { ITaskScheduler } from \"../interfaces/ITaskScheduler\";\r\nimport { createPromise } from \"../promise/promise\";\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"../promise/debug\";\r\n//#endif\r\n\r\nconst REJECT = \"reject\";\r\nconst REJECTED_ERROR = \"Rejected\";\r\n\r\nlet _schedulerId: number = 0;\r\nlet _debugName: any;\r\nlet _debugIntState: any;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nlet _customErrors: { [type: string]: CustomErrorConstructor } = {};\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal structure for report the debugging state\r\n */\r\ninterface _InternalDebugState {\r\n    l: ITaskDetail,\r\n    r: ITaskDetail[],\r\n    w: ITaskDetail[]\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Empty reject function to avoid trying to re-reject\r\n */\r\nfunction _rejectDone() {\r\n    // A Do nothing function\r\n}\r\n\r\nfunction _createError(type: string, evt: ITaskDetail, message?: string): Error {\r\n    // Lazily create the class\r\n    !_customErrors[type] && (_customErrors[type] = createCustomError(type));\r\n\r\n    let now = utcNow();\r\n    return new (_customErrors[type])(`Task [${evt.id}] ${message||\"\"}- ${(evt.st ? \"Running\" : \"Waiting\")}: ${_calcTime(now, evt.st || evt.cr)}`);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function used for displaying the time in milliseconds (during debugging)\r\n * @param now - The current time\r\n * @param start - The start time to subtract\r\n * @returns A string representation of the time difference\r\n */\r\nfunction _calcTime(now: number, start: number) {\r\n    return ((now - start) || \"0\") + \" ms\";\r\n}\r\n\r\n/**\r\n * Abort any stale tasks in the provided task Queue\r\n * @param taskQueue - The Task Queue to search\r\n * @param staleTimeoutPeriod - The maxumum stale timeout period\r\n */\r\nfunction _abortStaleTasks(taskQueue: ITaskDetail[], staleTimeoutPeriod: number): void {\r\n    let now = utcNow();\r\n    let expired = now - staleTimeoutPeriod;\r\n    arrForEach(taskQueue, (evt) => {\r\n        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {\r\n            evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Remove the `taskDetail` from the `queue` if present\r\n * @param queue - The Task Queue\r\n * @param taskDetail - The Task detail to be removed\r\n */\r\nfunction _removeTask(queue: ITaskDetail[], taskDetail: ITaskDetail): void {\r\n    let idx = arrIndexOf(queue, taskDetail);\r\n    if (idx !== -1) {\r\n        queue.splice(idx, 1);\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore Internal function to add the debug state to the promise, this code is removed from the production artifacts\r\n * @param theScheduler - The scheduler instance to add the debug accessors to.\r\n * @param nameFn - The function to return then name of this scheduler\r\n * @param stateFn - The function to return the internal state of the scheduler\r\n */\r\nfunction _addDebugState(theScheduler: any, nameFn: () => string, stateFn: () => _InternalDebugState) {\r\n    _debugName = _debugName || { toString: () => \"[[SchedulerName]]\" };\r\n    _debugIntState = _debugIntState || { toString: () => \"[[SchedulerState]]\" };\r\n    \r\n    objDefineProp(theScheduler, _debugName, { get: nameFn });\r\n    objDefineProp(theScheduler, _debugIntState, { get: stateFn });\r\n}\r\n\r\n/**\r\n * Create a Task Scheduler using the optional promise implementation and scheduler name.\r\n * The newPromise can be any value promise creation function, where the execution of the\r\n * queued tasks will be processed based on how the promise implementation processes it's\r\n * chained promises (asynchrounsly; synchronously; idle processing, etc)\r\n *\r\n * The functions used to start each task my return a result (synchronous execution) or an\r\n * {@link IPromise}, `PromiseLike` or `Promise` result (asynchronous execution).\r\n *\r\n * Each task is executed in the order that it was queued and the provided `startTask` function\r\n * will not be called until all previous tasks have completed (whther they resolve or reject).\r\n * The result from any previous task does not affect and is not passed to any later scheduled\r\n * task, if you need this capability then your `startTask` functions will need to co-operate to\r\n * share any common context.\r\n *\r\n * By default, queued tasks which have either been \"waiting\" to run or have been running longer\r\n * then 10 minutes will be Auto-Rejected to try and free up resources. If a task is running when\r\n * it rejected then it will continue to \"run\" based on whatever operation it's `startTask` is\r\n * performing. If a task has not yet had it's `startTask` function called it will never get called.\r\n * In both cases the `IPromise` returned by the call to {@link ITaskScheduler.queue | queue} the\r\n * task will be `rejected`. You can change this default time, including disabling completly via\r\n * the {@link ITaskScheduler.setStaleTimeout | setStaleTimeout}\r\n * function.\r\n * @since 0.2.0\r\n * @group Scheduler\r\n * @param newPromise - The function to use for creating a new promise when required, if not\r\n * provided this will default to {@link createPromise} which will use the default registered\r\n * promise creation function which defaults to runtime native promises or async Promise if not\r\n * supported by the runtime.\r\n * @param name - The name you want to associated with this scheduler, mostly useful for debugging\r\n * @returns A new ITaskScheduler instance\r\n * @example\r\n * ```ts\r\n * let scheduler = createTaskScheduler();\r\n *\r\n * // Schedule a task using the ts-async helper promise functions\r\n * scheduler.queue(() => {\r\n *     return createPromise((resolve, reject) => {\r\n *         scheduleTimeout(() => {\r\n *             // Do something after a delay\r\n *         }, 100);\r\n *     });\r\n * });\r\n *\r\n * // Schedule an asynchronous task which uses async/await\r\n * scheduler.queue(async () => {\r\n *     // This task will only execute after the previous task has completed\r\n *     await performAnotherAsyncTask();\r\n * });\r\n *\r\n * // Schedule a synchronous task that executes and completes immediately\r\n * scheduled.queue(() => {\r\n *     // Do some synchronous task\r\n *     return 42;\r\n * });\r\n *\r\n * // Schedule an asynchronous task which returns a promise\r\n * scheduled.queue(() => {\r\n *     return doAwait(fetch(\"https://github.com/nevware21/ts-async/blob/main/README.md\"), (response) => {\r\n *         let theReadMe = response.text();\r\n *         // Do something with the readme\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport function createTaskScheduler(newPromise?: <T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>, name?: string): ITaskScheduler {\r\n    let _theTask: ITaskDetail;\r\n    let _running: ITaskDetail[] = [];\r\n    let _waiting: ITaskDetail[] = [];\r\n    let _staleTimeoutPeriod = 600000;            // 10 Minutes\r\n    let _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;    // 1 Minute\r\n    let _taskCount = 0;\r\n    let _schedulerName = (name ? (name + \".\") : \"\") + _schedulerId++;\r\n    let _blockedTimer: ITimerHandler;\r\n\r\n    // Make sure that a promise creator has been assigned\r\n    newPromise = newPromise || createPromise;\r\n\r\n    const _startBlockedTimer = () => {\r\n        let hasTasks = (getLength(_running) + getLength(_waiting)) > 0;\r\n        if (_staleTimeoutPeriod > 0) {\r\n            if (!_blockedTimer) {\r\n                // Only attempt to drop stale / blocked tasks if the timeout period is defined\r\n                _blockedTimer = scheduleTimeout(() => {\r\n                    _abortStaleTasks(_running, _staleTimeoutPeriod);\r\n                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);\r\n                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));\r\n                }, _staleTimeoutCheckPeriod);\r\n\r\n                _blockedTimer.unref();\r\n            }\r\n\r\n            _blockedTimer && (_blockedTimer.enabled = hasTasks);\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"Stale Timer disabled\");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    const _queueTask = <T>(startAction: StartQueuedTaskFn<T>, taskName?: string, timeout?: number): IPromise<T> => {\r\n        let taskId: string = _schedulerName + \".\" + _taskCount++;\r\n        if (taskName) {\r\n            taskId += \"-(\" + taskName + \")\";\r\n        }\r\n       \r\n        let newTask: ITaskDetail = {\r\n            id: taskId,\r\n            cr: utcNow(),\r\n            to: timeout,\r\n            [REJECT]: (reason: any) => {\r\n                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\r\n                newTask[REJECT] = _rejectDone;\r\n            }\r\n        };\r\n\r\n        if (!_theTask) {\r\n            // We don't have any currently running task, so just start the next task\r\n            newTask.p = newPromise(_runTask(newTask, startAction));\r\n        } else {\r\n            // Start a new promise which will wait until all current active tasks are completed before starting\r\n            // the new task, it does not resolve this scheduled task until after the new task is resolve to\r\n            // ensure that all scheduled tasks are completed in the correct order\r\n            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\r\n        }\r\n\r\n        // Set this new task as the last one, so that any future tasks will wait for this one\r\n        _theTask = newTask;\r\n\r\n        return newTask.p;\r\n    }\r\n\r\n    const _runTask = <T>(taskDetail: ITaskDetail, startAction: StartQueuedTaskFn<T>): PromiseExecutor<T> => {\r\n        taskDetail.st = utcNow();\r\n\r\n        // There should only ever be a single \"running\" task, but using an array\r\n        // for code reuse.\r\n        _running.push(taskDetail);\r\n        _startBlockedTimer();\r\n\r\n        // Create and return the promise executor for this action\r\n        return <T>(onTaskResolve: ResolvePromiseHandler<T>, onTaskReject: RejectPromiseHandler) => {\r\n            const _promiseReject = (reason: any) => {\r\n                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\r\n                taskDetail[REJECT] = _rejectDone;\r\n                _doCleanup(taskDetail);\r\n                onTaskResolve = null;\r\n                onTaskReject && onTaskReject(reason);\r\n                onTaskReject = null;\r\n            }\r\n\r\n            let taskId = taskDetail.id;\r\n\r\n            if (taskDetail.rj) {\r\n                // Already aborted / pre-rejected\r\n                _promiseReject(taskDetail.rj);\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_schedulerName, \"Task [\" + taskId + \"] Started after \" + _calcTime(taskDetail.st, taskDetail.cr));\r\n                //#endif\r\n                taskDetail[REJECT] = _promiseReject;\r\n\r\n                try {\r\n                    let startResult = startAction(taskId);\r\n                    if (taskDetail.to && isPromiseLike(startResult)) {\r\n                        taskDetail.t = scheduleTimeout(() => {\r\n                            _promiseReject(_createError(\"Timeout\", taskDetail));\r\n                        }, taskDetail.to);\r\n                    }\r\n\r\n                    doAwait(startResult, (theResult) => {\r\n                        _doCleanup(taskDetail);\r\n                        try {\r\n                            onTaskResolve && onTaskResolve(theResult as any);\r\n                        } catch (e) {\r\n                            onTaskReject && onTaskReject(e);\r\n                        }\r\n                        onTaskReject = null;\r\n                        onTaskResolve = null;\r\n                    }, _promiseReject);\r\n                } catch (e) {\r\n                    _promiseReject(e);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    const _waitForPreviousTask = <T>(taskDetail: ITaskDetail, prevTask: ITaskDetail, startAction: StartQueuedTaskFn<T>): IPromise<T> => {\r\n        _waiting.push(taskDetail);\r\n        _startBlockedTimer();\r\n\r\n        return newPromise((onWaitResolve, onWaitReject) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) let taskId = taskDetail.id;\r\n            //#:(!DEBUG) let prevTaskId = prevTask.id;\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"[\" + taskId + \"] is waiting for [\" + prevTaskId + \"] to complete before starting -- [\" + _waiting.length + \"] waiting\");\r\n            //#endif\r\n\r\n            // Wait for the previous tasks to complete before starting this one.\r\n            // This ensures the queue execution order and avoids removing tasks that\r\n            // have not yet been started.\r\n            doAwaitResponse(prevTask.p, () => {\r\n                _removeTask(_waiting, taskDetail);\r\n                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\r\n            });\r\n        });\r\n    }\r\n\r\n    const _doCleanup = (taskDetail: ITaskDetail) => {\r\n        _removeTask(_running, taskDetail);\r\n\r\n        // If there was a timeout stop and clear\r\n        taskDetail.t && taskDetail.t.cancel();\r\n        taskDetail.t = null;\r\n\r\n        // Clear the matching current task now that it's complete\r\n        if (_theTask && _theTask === taskDetail) {\r\n            _theTask = null;\r\n            if (getLength(_running) + getLength(_waiting) === 0) {\r\n                _blockedTimer && _blockedTimer.cancel();\r\n                _blockedTimer = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    let theScheduler: ITaskScheduler =  {\r\n        idle: true,\r\n        queue: _queueTask,\r\n        setStaleTimeout: (staleTimeout: number, staleCheckPeriod?: number) => {\r\n            _blockedTimer && _blockedTimer.cancel();\r\n            _blockedTimer = null;\r\n            _staleTimeoutPeriod = staleTimeout;\r\n            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\r\n            _startBlockedTimer();\r\n        }\r\n    };\r\n\r\n    // Change the idle property to dynamic\r\n    objDefine(theScheduler, \"idle\", {\r\n        g: () => {\r\n            return getLength(_running) + getLength(_waiting) === 0;\r\n        }\r\n    });\r\n\r\n    _addDebugState(theScheduler, () => _schedulerName,\r\n        () => {\r\n            return {\r\n                l: _theTask,\r\n                r: _running,\r\n                w: _waiting\r\n            }\r\n        });\r\n\r\n    return theScheduler;\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getKnownSymbol, objDefineProp, WellKnownSymbols } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\nconst toStringTagSymbol: symbol = getKnownSymbol(WellKnownSymbols.toStringTag) as typeof Symbol.toStringTag;\r\n\r\n/**\r\n * The PolyPromiseConstructor interface represents the constructor for the polyfill Promise object.\r\n * @since 0.5.0\r\n * @group Polyfill\r\n */\r\nexport interface PolyPromiseConstructor {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    new <T>(executor: PromiseExecutor<T>): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n     * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n     * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n     * and will reject with this first rejection message / error.\r\n     * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns\r\n     * <ul>\r\n     * <li> An already resolved `Promise`, if the input passed is empty.\r\n     * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n     * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n     * promises reject.\r\n     * </ul>\r\n     */\r\n    all<T>(input: Iterable<PromiseLike<T>>, timeout?: number): IPromise<T[]>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n     * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n     * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param reason - The rejection reason\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A rejected promise.\r\n     */\r\n    reject<T = never>(reason?: any, timeout?: number): IPromise<T>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve(): IPromise<void>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve<T>(value: T | PromiseLike<T>, timeout?: number): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T extends readonly unknown[] | []>(values: T, timeout?: number): Promise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n}\r\n\r\n/**\r\n * A full polyfill for the Promise class.\r\n * Represents the completion of an asynchronous operation, and its resulting value.\r\n * @since 0.5.0\r\n * @class\r\n * @group Polyfill\r\n * @group Promise\r\n */\r\nexport let PolyPromise = /*#__PURE__*/(function () {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    function PolyPromiseImpl<T>(executor: PromiseExecutor<T>) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function() {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     */\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.any = createAsyncAnyPromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\r\n    let theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved: any, onRejected: any) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected: any) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally: any) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl as unknown as PolyPromiseConstructor;\r\n}());"],"names":["_addDebugState"],"mappings":"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"}