{"version":3,"file":"Exception.js.map","sources":["Exception.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { __assign } from \"tslib\";\r\nimport { arrForEach, arrMap, isArray, isError, isFunction, isNullOrUndefined, isObject, isString, strTrim } from \"@microsoft/applicationinsights-core-js\";\r\nimport { asString, getWindow, objFreeze, strIndexOf } from \"@nevware21/ts-utils\";\r\nimport { strNotSpecified } from \"../Constants\";\r\nimport { _DYN_AI_DATA_CONTRACT, _DYN_ASSEMBLY, _DYN_EXCEPTIONS, _DYN_FILE_NAME, _DYN_HAS_FULL_STACK, _DYN_LENGTH, _DYN_LINE, _DYN_MATCH, _DYN_MEASUREMENTS, _DYN_MESSAGE, _DYN_NAME, _DYN_PARSED_STACK, _DYN_PROBLEM_GROUP, _DYN_PROPERTIES, _DYN_SEVERITY_LEVEL, _DYN_SIZE_IN_BYTES, _DYN_SPLIT, _DYN_STRINGIFY, _DYN_TO_STRING, _DYN_TYPE_NAME } from \"../__DynamicConstants\";\r\nimport { dataSanitizeException, dataSanitizeMeasurements, dataSanitizeMessage, dataSanitizeProperties, dataSanitizeString } from \"./Common/DataSanitizer\";\r\n// These Regex covers the following patterns\r\n// 1. Chrome/Firefox/IE/Edge:\r\n//    at functionName (filename:lineNumber:columnNumber)\r\n//    at functionName (filename:lineNumber)\r\n//    at filename:lineNumber:columnNumber\r\n//    at filename:lineNumber\r\n//    at functionName@filename:lineNumber:columnNumber\r\n// 2. Safari / Opera:\r\n//    functionName@filename:lineNumber:columnNumber\r\n//    functionName@filename:lineNumber\r\n//    filename:lineNumber:columnNumber\r\n//    filename:lineNumber\r\n//    Line ## of scriptname script filename:lineNumber:columnNumber\r\n//    Line ## of scriptname script filename\r\n// 3. IE/Edge (Additional formats)\r\n//    at functionName@filename:lineNumber\r\nvar STACKFRAME_BASE_SIZE = 58; // '{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\r\n/**\r\n * Check if the string conforms to what looks like a stack frame line and not just a general message\r\n * comment or other non-stack related info.\r\n *\r\n * This  should be used to filter out any leading \"message\" lines from a stack trace, before attempting to parse\r\n * the individual stack frames. Once you have estabilsted the start of the stack frames you can then use the\r\n * FULL_STACK_FRAME_1, FULL_STACK_FRAME_2, FULL_STACK_FRAME_3, and EXTRACT_FILENAME to parse the individual\r\n * stack frames to extract the method, filename, line number, and column number.\r\n * These may still provide invalid matches, so the sequence of execution is important to avoid providing\r\n * an invalid parsed stack.\r\n */\r\nvar IS_FRAME = /^\\s{0,50}(from\\s|at\\s|Line\\s{1,5}\\d{1,10}\\s{1,5}of|\\w{1,50}@\\w{1,80}|[^\\(\\s\\n]+:[0-9\\?]+(?::[0-9\\?]+)?)/;\r\n/**\r\n * Parse a well formed stack frame with both the line and column numbers\r\n * ----------------------------------\r\n * **Primary focus of the matching**\r\n * - at functionName (filename:lineNumber:columnNumber)\r\n * - at filename:lineNumber:columnNumber\r\n * - at functionName@filename:lineNumber:columnNumber\r\n * - functionName (filename:lineNumber:columnNumber)\r\n * - filename:lineNumber:columnNumber\r\n * - functionName@filename:lineNumber:columnNumber\r\n */\r\nvar FULL_STACK_FRAME_1 = /^(?:\\s{0,50}at)?\\s{0,50}([^\\@\\()\\s]+)?\\s{0,50}(?:\\s|\\@|\\()\\s{0,5}([^\\(\\s\\n\\]]+):([0-9\\?]+):([0-9\\?]+)\\)?$/;\r\n/**\r\n * Parse a well formed stack frame with only a line number.\r\n * ----------------------------------\r\n * > Note: this WILL also match with line and column number, but the line number is included with the filename\r\n * > you should attempt to match with FULL_STACK_FRAME_1 first.\r\n *\r\n * **Primary focus of the matching (run FULL_STACK_FRAME_1 first)**\r\n * - at functionName (filename:lineNumber)\r\n * - at filename:lineNumber\r\n * - at functionName@filename:lineNumber\r\n * - functionName (filename:lineNumber)\r\n * - filename:lineNumber\r\n * - functionName@filename:lineNumber\r\n *\r\n * **Secondary matches**\r\n * - at functionName (filename:lineNumber:columnNumber)\r\n * - at filename:lineNumber:columnNumber\r\n * - at functionName@filename:lineNumber:columnNumber\r\n * - functionName (filename:lineNumber:columnNumber)\r\n * - filename:lineNumber:columnNumber\r\n * - functionName@filename:lineNumber:columnNumber\r\n */\r\nvar FULL_STACK_FRAME_2 = /^(?:\\s{0,50}at)?\\s{0,50}([^\\@\\()\\s]+)?\\s{0,50}(?:\\s|\\@|\\()\\s{0,5}([^\\(\\s\\n\\]]+):([0-9\\?]+)\\)?$/;\r\n/**\r\n * Attempt to Parse a frame that doesn't include a line or column number.\r\n * ----------------------------------\r\n * > Note: this WILL also match lines with a line or line and column number, you should attempt to match with\r\n * both FULL_STACK_FRAME_1 and FULL_STACK_FRAME_2 first to avoid false positives.\r\n *\r\n * **Unexpected Invalid Matches** (Matches that should be avoided -- by using the FULL_STACK_FRAME_1 and FULL_STACK_FRAME_2 first)\r\n * - at https://localhost:44365/static/node_bundles/@microsoft/blah/js/bundle.js:144112:27\r\n * - at https://localhost:44365/static/node_bundles/@microsoft/blah/js/bundle.js:144112:27\r\n *\r\n * **Primary focus of the matching (run FULL_STACK_FRAME_1 first)**\r\n * - at functionName@filename\r\n * - at functionName (filename)\r\n * - at functionName filename\r\n * - at filename  <- Will actuall match this as the \"method\" and not the filename (care should be taken to avoid this)\r\n * - functionName@filename\r\n * - functionName (filename)\r\n * - functionName filename\r\n * - functionName\r\n *\r\n * **Secondary matches** (The line and column numbers will be included with the matched filename)\r\n * - at functionName (filename:lineNumber:columnNumber)\r\n * - at functionName (filename:lineNumber)\r\n * - at filename:lineNumber:columnNumber\r\n * - at filename:lineNumber\r\n * - at functionName@filename:lineNumber:columnNumber\r\n * - at functionName@filename:lineNumber\r\n * - functionName (filename:lineNumber:columnNumber)\r\n * - functionName (filename:lineNumber)\r\n * - filename:lineNumber:columnNumber\r\n * - filename:lineNumber\r\n * - functionName@filename:lineNumber:columnNumber\r\n * - functionName@filename:lineNumber\r\n  */\r\nvar FULL_STACK_FRAME_3 = /^(?:\\s{0,50}at)?\\s{0,50}([^\\@\\()\\s]+)?\\s{0,50}(?:\\s|\\@|\\()\\s{0,5}([^\\(\\s\\n\\)\\]]+)\\)?$/;\r\n/**\r\n * Attempt to extract the filename (with or without line and column numbers) from a string.\r\n * ----------------------------------\r\n * > Note: this will only match the filename (with any line or column numbers) and will\r\n * > return what looks like the filename, however, it will also match random strings that\r\n * > look like a filename, so care should be taken to ensure that the filename is actually\r\n * > a filename before using it.\r\n * >\r\n * > It is recommended to use this in conjunction with the FULL_STACK_FRAME_1, FULL_STACK_FRAME_2, and FULL_STACK_FRAME_3\r\n * > to ensure first to reduce false matches, if all of these fail then you can use this to extract the filename from a random\r\n * > strings to identify any potential filename from a known stack frame line.\r\n *\r\n * **Known Invalid matching**\r\n *\r\n * This regex will basically match any \"final\" string of a line or one that is trailed by a comma, so this should not\r\n * be used as the \"only\" matching regex, but rather as a final fallback to extract the filename from a string.\r\n * If you are certain that the string line is a stack frame and not part of the exception message (lines before the stack)\r\n * or trailing comments, then you can use this to extract the filename and then further parse with PARSE_FILENAME_LINE_COL\r\n * and PARSE_FILENAME_LINE_ONLY to extract any potential the line and column numbers.\r\n *\r\n * **Primary focus of the matching**\r\n * - at (anonymous) @ VM60:1\r\n * - Line 21 of linked script file://localhost/C:/Temp/stacktrace.js\r\n * - Line 11 of inline#1 script in http://localhost:3000/static/js/main.206f4846.js:2:296748\r\n * - Line 68 of inline#2 script in file://localhost/teststack.html\r\n * - at Global code (http://example.com/stacktrace.js:11:1)\r\n */\r\nvar EXTRACT_FILENAME = /(?:^|\\(|\\s{0,10}[\\w\\)]+\\@)?([^\\(\\n\\s\\]\\)]+)(?:\\:([0-9]+)(?:\\:([0-9]+))?)?\\)?(?:,|$)/;\r\n/**\r\n * Attempt to extract the filename, line number, and column number from a string.\r\n */\r\nvar PARSE_FILENAME_LINE_COL = /([^\\(\\s\\n]+):([0-9]+):([0-9]+)$/;\r\n/**\r\n * Attempt to extract the filename and line number from a string.\r\n */\r\nvar PARSE_FILENAME_LINE_ONLY = /([^\\(\\s\\n]+):([0-9]+)$/;\r\nvar NoMethod = \"<no_method>\";\r\nvar strError = \"error\";\r\nvar strStack = \"stack\";\r\nvar strStackDetails = \"stackDetails\";\r\nvar strErrorSrc = \"errorSrc\";\r\nvar strMessage = \"message\";\r\nvar strDescription = \"description\";\r\nvar _parseSequence = [\r\n    { re: FULL_STACK_FRAME_1, len: 5, m: 1, fn: 2, ln: 3, col: 4 },\r\n    { chk: _ignoreNative, pre: _scrubAnonymous, re: FULL_STACK_FRAME_2, len: 4, m: 1, fn: 2, ln: 3 },\r\n    { re: FULL_STACK_FRAME_3, len: 3, m: 1, fn: 2, hdl: _handleFilename },\r\n    { re: EXTRACT_FILENAME, len: 2, fn: 1, hdl: _handleFilename }\r\n];\r\nfunction _scrubAnonymous(frame) {\r\n    return frame.replace(/(\\(anonymous\\))/, \"<anonymous>\");\r\n}\r\nfunction _ignoreNative(frame) {\r\n    return strIndexOf(frame, \"[native\") < 0;\r\n}\r\nfunction _stringify(value, convertToString) {\r\n    var result = value;\r\n    if (result && !isString(result)) {\r\n        if (JSON && JSON[_DYN_STRINGIFY /* @min:%2estringify */]) {\r\n            result = JSON[_DYN_STRINGIFY /* @min:%2estringify */](value);\r\n            if (convertToString && (!result || result === \"{}\")) {\r\n                if (isFunction(value[_DYN_TO_STRING /* @min:%2etoString */])) {\r\n                    result = value[_DYN_TO_STRING /* @min:%2etoString */]();\r\n                }\r\n                else {\r\n                    result = \"\" + value;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result = \"\" + value + \" - (Missing JSON.stringify)\";\r\n        }\r\n    }\r\n    return result || \"\";\r\n}\r\nfunction _formatMessage(theEvent, errorType) {\r\n    var evtMessage = theEvent;\r\n    if (theEvent) {\r\n        if (evtMessage && !isString(evtMessage)) {\r\n            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;\r\n        }\r\n        // Make sure the message is a string\r\n        if (evtMessage && !isString(evtMessage)) {\r\n            // tslint:disable-next-line: prefer-conditional-expression\r\n            evtMessage = _stringify(evtMessage, true);\r\n        }\r\n        if (theEvent[\"filename\"]) {\r\n            // Looks like an event object with filename\r\n            evtMessage = evtMessage + \" @\" + (theEvent[\"filename\"] || \"\") + \":\" + (theEvent[\"lineno\"] || \"?\") + \":\" + (theEvent[\"colno\"] || \"?\");\r\n        }\r\n    }\r\n    // Automatically add the error type to the message if it does already appear to be present\r\n    if (errorType && errorType !== \"String\" && errorType !== \"Object\" && errorType !== \"Error\" && strIndexOf(evtMessage || \"\", errorType) === -1) {\r\n        evtMessage = errorType + \": \" + evtMessage;\r\n    }\r\n    return evtMessage || \"\";\r\n}\r\nfunction _isExceptionDetailsInternal(value) {\r\n    try {\r\n        if (isObject(value)) {\r\n            return \"hasFullStack\" in value && \"typeName\" in value;\r\n        }\r\n    }\r\n    catch (e) {\r\n        // This can happen with some native browser objects, but should not happen for the type we are checking for\r\n    }\r\n    return false;\r\n}\r\nfunction _isExceptionInternal(value) {\r\n    try {\r\n        if (isObject(value)) {\r\n            return (\"ver\" in value && \"exceptions\" in value && \"properties\" in value);\r\n        }\r\n    }\r\n    catch (e) {\r\n        // This can happen with some native browser objects, but should not happen for the type we are checking for\r\n    }\r\n    return false;\r\n}\r\nfunction _isStackDetails(details) {\r\n    return details && details.src && isString(details.src) && details.obj && isArray(details.obj);\r\n}\r\nfunction _convertStackObj(errorStack) {\r\n    var src = errorStack || \"\";\r\n    if (!isString(src)) {\r\n        if (isString(src[strStack])) {\r\n            src = src[strStack];\r\n        }\r\n        else {\r\n            src = \"\" + src;\r\n        }\r\n    }\r\n    var items = src[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\r\n    return {\r\n        src: src,\r\n        obj: items\r\n    };\r\n}\r\nfunction _getOperaStack(errorMessage) {\r\n    var stack = [];\r\n    var lines = errorMessage[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\r\n    for (var lp = 0; lp < lines[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n        var entry = lines[lp];\r\n        if (lines[lp + 1]) {\r\n            entry += \"@\" + lines[lp + 1];\r\n            lp++;\r\n        }\r\n        stack.push(entry);\r\n    }\r\n    return {\r\n        src: errorMessage,\r\n        obj: stack\r\n    };\r\n}\r\nfunction _getStackFromErrorObj(errorObj) {\r\n    var details = null;\r\n    if (errorObj) {\r\n        try {\r\n            /* Using bracket notation is support older browsers (IE 7/8 -- dont remember the version) that throw when using dot\r\n            notation for undefined objects and we don't want to loose the error from being reported */\r\n            if (errorObj[strStack]) {\r\n                // Chrome/Firefox\r\n                details = _convertStackObj(errorObj[strStack]);\r\n            }\r\n            else if (errorObj[strError] && errorObj[strError][strStack]) {\r\n                // Edge error event provides the stack and error object\r\n                details = _convertStackObj(errorObj[strError][strStack]);\r\n            }\r\n            else if (errorObj[\"exception\"] && errorObj.exception[strStack]) {\r\n                details = _convertStackObj(errorObj.exception[strStack]);\r\n            }\r\n            else if (_isStackDetails(errorObj)) {\r\n                details = errorObj;\r\n            }\r\n            else if (_isStackDetails(errorObj[strStackDetails])) {\r\n                details = errorObj[strStackDetails];\r\n            }\r\n            else if (getWindow() && getWindow()[\"opera\"] && errorObj[strMessage]) {\r\n                // Opera\r\n                details = _getOperaStack(errorObj[_DYN_MESSAGE /* @min:%2emessage */]);\r\n            }\r\n            else if (errorObj[\"reason\"] && errorObj.reason[strStack]) {\r\n                // UnhandledPromiseRejection\r\n                details = _convertStackObj(errorObj.reason[strStack]);\r\n            }\r\n            else if (isString(errorObj)) {\r\n                details = _convertStackObj(errorObj);\r\n            }\r\n            else {\r\n                var evtMessage = errorObj[strMessage] || errorObj[strDescription] || \"\";\r\n                if (isString(errorObj[strErrorSrc])) {\r\n                    if (evtMessage) {\r\n                        evtMessage += \"\\n\";\r\n                    }\r\n                    evtMessage += \" from \" + errorObj[strErrorSrc];\r\n                }\r\n                if (evtMessage) {\r\n                    details = _convertStackObj(evtMessage);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // something unexpected happened so to avoid failing to report any error lets swallow the exception\r\n            // and fallback to the callee/caller method\r\n            details = _convertStackObj(e);\r\n        }\r\n    }\r\n    return details || {\r\n        src: \"\",\r\n        obj: null\r\n    };\r\n}\r\nfunction _formatStackTrace(stackDetails) {\r\n    var stack = \"\";\r\n    if (stackDetails) {\r\n        if (stackDetails.obj) {\r\n            stack = stackDetails.obj.join(\"\\n\");\r\n        }\r\n        else {\r\n            stack = stackDetails.src || \"\";\r\n        }\r\n    }\r\n    return stack;\r\n}\r\nfunction _parseStack(stack) {\r\n    var parsedStack;\r\n    var frames = stack.obj;\r\n    if (frames && frames[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n        parsedStack = [];\r\n        var level_1 = 0;\r\n        var foundStackStart_1 = false;\r\n        var totalSizeInBytes_1 = 0;\r\n        arrForEach(frames, function (frame) {\r\n            if (foundStackStart_1 || _isStackFrame(frame)) {\r\n                var theFrame = asString(frame);\r\n                // Once we have found the first stack frame we treat the rest of the lines as part of the stack\r\n                foundStackStart_1 = true;\r\n                var parsedFrame = _extractStackFrame(theFrame, level_1);\r\n                if (parsedFrame) {\r\n                    totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                    parsedStack.push(parsedFrame);\r\n                    level_1++;\r\n                }\r\n            }\r\n        });\r\n        // DP Constraint - exception parsed stack must be < 32KB\r\n        // remove frames from the middle to meet the threshold\r\n        var exceptionParsedStackThreshold = 32 * 1024;\r\n        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {\r\n            var left = 0;\r\n            var right = parsedStack[_DYN_LENGTH /* @min:%2elength */] - 1;\r\n            var size = 0;\r\n            var acceptedLeft = left;\r\n            var acceptedRight = right;\r\n            while (left < right) {\r\n                // check size\r\n                var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                size += lSize + rSize;\r\n                if (size > exceptionParsedStackThreshold) {\r\n                    // remove extra frames from the middle\r\n                    var howMany = acceptedRight - acceptedLeft + 1;\r\n                    parsedStack.splice(acceptedLeft, howMany);\r\n                    break;\r\n                }\r\n                // update pointers\r\n                acceptedLeft = left;\r\n                acceptedRight = right;\r\n                left++;\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n    return parsedStack;\r\n}\r\nfunction _getErrorType(errorType) {\r\n    // Gets the Error Type by passing the constructor (used to get the true type of native error object).\r\n    var typeName = \"\";\r\n    if (errorType) {\r\n        typeName = errorType.typeName || errorType[_DYN_NAME /* @min:%2ename */] || \"\";\r\n        if (!typeName) {\r\n            try {\r\n                var funcNameRegex = /function (.{1,200})\\(/;\r\n                var results = (funcNameRegex).exec((errorType).constructor[_DYN_TO_STRING /* @min:%2etoString */]());\r\n                typeName = (results && results[_DYN_LENGTH /* @min:%2elength */] > 1) ? results[1] : \"\";\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\r\n            }\r\n        }\r\n    }\r\n    return typeName;\r\n}\r\n/**\r\n * Formats the provided errorObj for display and reporting, it may be a String, Object, integer or undefined depending on the browser.\r\n * @param errorObj - The supplied errorObj\r\n */\r\nexport function _formatErrorCode(errorObj) {\r\n    if (errorObj) {\r\n        try {\r\n            if (!isString(errorObj)) {\r\n                var errorType = _getErrorType(errorObj);\r\n                var result = _stringify(errorObj, false);\r\n                if (!result || result === \"{}\") {\r\n                    if (errorObj[strError]) {\r\n                        // Looks like an MS Error Event\r\n                        errorObj = errorObj[strError];\r\n                        errorType = _getErrorType(errorObj);\r\n                    }\r\n                    result = _stringify(errorObj, true);\r\n                }\r\n                if (strIndexOf(result, errorType) !== 0 && errorType !== \"String\") {\r\n                    return errorType + \":\" + result;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\r\n        }\r\n    }\r\n    // Fallback to just letting the object format itself into a string\r\n    return \"\" + (errorObj || \"\");\r\n}\r\nvar Exception = /** @class */ (function () {\r\n    /**\r\n     * Constructs a new instance of the ExceptionTelemetry object\r\n     */\r\n    function Exception(logger, exception, properties, measurements, severityLevel, id) {\r\n        this.aiDataContract = {\r\n            ver: 1 /* FieldType.Required */,\r\n            exceptions: 1 /* FieldType.Required */,\r\n            severityLevel: 0 /* FieldType.Default */,\r\n            properties: 0 /* FieldType.Default */,\r\n            measurements: 0 /* FieldType.Default */\r\n        };\r\n        var _self = this;\r\n        _self.ver = 2; // TODO: handle the CS\"4.0\" ==> breeze 2 conversion in a better way\r\n        if (!_isExceptionInternal(exception)) {\r\n            if (!properties) {\r\n                properties = {};\r\n            }\r\n            if (id) {\r\n                properties.id = id;\r\n            }\r\n            _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = [_createExceptionDetails(logger, exception, properties)];\r\n            _self[_DYN_PROPERTIES /* @min:%2eproperties */] = dataSanitizeProperties(logger, properties);\r\n            _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = dataSanitizeMeasurements(logger, measurements);\r\n            if (severityLevel) {\r\n                _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;\r\n            }\r\n            if (id) {\r\n                _self.id = id;\r\n            }\r\n        }\r\n        else {\r\n            _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */] || [];\r\n            _self[_DYN_PROPERTIES /* @min:%2eproperties */] = exception[_DYN_PROPERTIES /* @min:%2eproperties */];\r\n            _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = exception[_DYN_MEASUREMENTS /* @min:%2emeasurements */];\r\n            if (exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */]) {\r\n                _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */];\r\n            }\r\n            if (exception.id) {\r\n                _self.id = exception.id;\r\n                exception[_DYN_PROPERTIES /* @min:%2eproperties */].id = exception.id;\r\n            }\r\n            if (exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */]) {\r\n                _self[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */] = exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */];\r\n            }\r\n            // bool/int types, use isNullOrUndefined\r\n            if (!isNullOrUndefined(exception.isManual)) {\r\n                _self.isManual = exception.isManual;\r\n            }\r\n        }\r\n    }\r\n    Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {\r\n        var errorType = _getErrorType(error || evt || message);\r\n        return {\r\n            message: _formatMessage(message, errorType),\r\n            url: url,\r\n            lineNumber: lineNumber,\r\n            columnNumber: columnNumber,\r\n            error: _formatErrorCode(error || evt || message),\r\n            evt: _formatErrorCode(evt || message),\r\n            typeName: errorType,\r\n            stackDetails: _getStackFromErrorObj(stack || error || evt),\r\n            errorSrc: errorSrc\r\n        };\r\n    };\r\n    Exception.CreateFromInterface = function (logger, exception, properties, measurements) {\r\n        var exceptions = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */]\r\n            && arrMap(exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */], function (ex) { return _createExDetailsFromInterface(logger, ex); });\r\n        var exceptionData = new Exception(logger, __assign(__assign({}, exception), { exceptions: exceptions }), properties, measurements);\r\n        return exceptionData;\r\n    };\r\n    Exception.prototype.toInterface = function () {\r\n        var _a = this, exceptions = _a.exceptions, properties = _a.properties, measurements = _a.measurements, severityLevel = _a.severityLevel, problemGroup = _a.problemGroup, id = _a.id, isManual = _a.isManual;\r\n        var exceptionDetailsInterface = exceptions instanceof Array\r\n            && arrMap(exceptions, function (exception) { return exception.toInterface(); })\r\n            || undefined;\r\n        return {\r\n            ver: \"4.0\",\r\n            exceptions: exceptionDetailsInterface,\r\n            severityLevel: severityLevel,\r\n            properties: properties,\r\n            measurements: measurements,\r\n            problemGroup: problemGroup,\r\n            id: id,\r\n            isManual: isManual\r\n        };\r\n    };\r\n    /**\r\n     * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.\r\n     */\r\n    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {\r\n        var _a;\r\n        return {\r\n            exceptions: [\r\n                (_a = {},\r\n                    _a[_DYN_HAS_FULL_STACK /* @min:hasFullStack */] = true,\r\n                    _a.message = message,\r\n                    _a.stack = details,\r\n                    _a.typeName = typeName,\r\n                    _a)\r\n            ]\r\n        };\r\n    };\r\n    Exception.envelopeType = \"Microsoft.ApplicationInsights.{0}.Exception\";\r\n    Exception.dataType = \"ExceptionData\";\r\n    Exception.formatError = _formatErrorCode;\r\n    return Exception;\r\n}());\r\nexport { Exception };\r\nvar exDetailsAiDataContract = objFreeze({\r\n    id: 0 /* FieldType.Default */,\r\n    outerId: 0 /* FieldType.Default */,\r\n    typeName: 1 /* FieldType.Required */,\r\n    message: 1 /* FieldType.Required */,\r\n    hasFullStack: 0 /* FieldType.Default */,\r\n    stack: 0 /* FieldType.Default */,\r\n    parsedStack: 2 /* FieldType.Array */\r\n});\r\nfunction _toInterface() {\r\n    var _self = this;\r\n    var parsedStack = isArray(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */])\r\n        && arrMap(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return _parsedFrameToInterface(frame); });\r\n    var exceptionDetailsInterface = {\r\n        id: _self.id,\r\n        outerId: _self.outerId,\r\n        typeName: _self[_DYN_TYPE_NAME /* @min:%2etypeName */],\r\n        message: _self[_DYN_MESSAGE /* @min:%2emessage */],\r\n        hasFullStack: _self[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */],\r\n        stack: _self[strStack],\r\n        parsedStack: parsedStack || undefined\r\n    };\r\n    return exceptionDetailsInterface;\r\n}\r\nexport function _createExceptionDetails(logger, exception, properties) {\r\n    var _a;\r\n    var id;\r\n    var outerId;\r\n    var typeName;\r\n    var message;\r\n    var hasFullStack;\r\n    var theStack;\r\n    var parsedStack;\r\n    if (!_isExceptionDetailsInternal(exception)) {\r\n        var error = exception;\r\n        var evt = error && error.evt;\r\n        if (!isError(error)) {\r\n            error = error[strError] || evt || error;\r\n        }\r\n        typeName = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified;\r\n        message = dataSanitizeMessage(logger, _formatMessage(exception || error, typeName)) || strNotSpecified;\r\n        var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);\r\n        parsedStack = _parseStack(stack);\r\n        // after parsedStack is inited, iterate over each frame object, sanitize its assembly field\r\n        if (isArray(parsedStack)) {\r\n            arrMap(parsedStack, function (frame) {\r\n                frame[_DYN_ASSEMBLY /* @min:%2eassembly */] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY /* @min:%2eassembly */]);\r\n                frame[_DYN_FILE_NAME /* @min:%2efileName */] = dataSanitizeString(logger, frame[_DYN_FILE_NAME /* @min:%2efileName */]);\r\n            });\r\n        }\r\n        theStack = dataSanitizeException(logger, _formatStackTrace(stack));\r\n        hasFullStack = isArray(parsedStack) && parsedStack[_DYN_LENGTH /* @min:%2elength */] > 0;\r\n        if (properties) {\r\n            properties[_DYN_TYPE_NAME /* @min:%2etypeName */] = properties[_DYN_TYPE_NAME /* @min:%2etypeName */] || typeName;\r\n        }\r\n    }\r\n    else {\r\n        typeName = exception[_DYN_TYPE_NAME /* @min:%2etypeName */];\r\n        message = exception[_DYN_MESSAGE /* @min:%2emessage */];\r\n        theStack = exception[strStack];\r\n        parsedStack = exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */] || [];\r\n        hasFullStack = exception[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */];\r\n    }\r\n    return _a = {},\r\n        _a[_DYN_AI_DATA_CONTRACT /* @min:aiDataContract */] = exDetailsAiDataContract,\r\n        _a.id = id,\r\n        _a.outerId = outerId,\r\n        _a.typeName = typeName,\r\n        _a.message = message,\r\n        _a[_DYN_HAS_FULL_STACK /* @min:hasFullStack */] = hasFullStack,\r\n        _a.stack = theStack,\r\n        _a.parsedStack = parsedStack,\r\n        _a.toInterface = _toInterface,\r\n        _a;\r\n}\r\nexport function _createExDetailsFromInterface(logger, exception) {\r\n    var parsedStack = (isArray(exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */])\r\n        && arrMap(exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return _stackFrameFromInterface(frame); }))\r\n        || exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */];\r\n    var exceptionDetails = _createExceptionDetails(logger, __assign(__assign({}, exception), { parsedStack: parsedStack }));\r\n    return exceptionDetails;\r\n}\r\nfunction _parseFilename(theFrame, fileName) {\r\n    var lineCol = fileName[_DYN_MATCH /* @min:%2ematch */](PARSE_FILENAME_LINE_COL);\r\n    if (lineCol && lineCol[_DYN_LENGTH /* @min:%2elength */] >= 4) {\r\n        theFrame[_DYN_FILE_NAME /* @min:%2efileName */] = lineCol[1];\r\n        theFrame[_DYN_LINE /* @min:%2eline */] = parseInt(lineCol[2]);\r\n    }\r\n    else {\r\n        var lineNo = fileName[_DYN_MATCH /* @min:%2ematch */](PARSE_FILENAME_LINE_ONLY);\r\n        if (lineNo && lineNo[_DYN_LENGTH /* @min:%2elength */] >= 3) {\r\n            theFrame[_DYN_FILE_NAME /* @min:%2efileName */] = lineNo[1];\r\n            theFrame[_DYN_LINE /* @min:%2eline */] = parseInt(lineNo[2]);\r\n        }\r\n        else {\r\n            theFrame[_DYN_FILE_NAME /* @min:%2efileName */] = fileName;\r\n        }\r\n    }\r\n}\r\nfunction _handleFilename(theFrame, sequence, matches) {\r\n    var filename = theFrame[_DYN_FILE_NAME /* @min:%2efileName */];\r\n    if (sequence.fn && matches && matches[_DYN_LENGTH /* @min:%2elength */] > sequence.fn) {\r\n        if (sequence.ln && matches[_DYN_LENGTH /* @min:%2elength */] > sequence.ln) {\r\n            filename = strTrim(matches[sequence.fn] || \"\");\r\n            theFrame[_DYN_LINE /* @min:%2eline */] = parseInt(strTrim(matches[sequence.ln] || \"\")) || 0;\r\n        }\r\n        else {\r\n            filename = strTrim(matches[sequence.fn] || \"\");\r\n        }\r\n    }\r\n    if (filename) {\r\n        _parseFilename(theFrame, filename);\r\n    }\r\n}\r\nfunction _isStackFrame(frame) {\r\n    var result = false;\r\n    if (frame && isString(frame)) {\r\n        var trimmedFrame = strTrim(frame);\r\n        if (trimmedFrame) {\r\n            result = IS_FRAME.test(trimmedFrame);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nvar stackFrameAiDataContract = objFreeze({\r\n    level: 1 /* FieldType.Required */,\r\n    method: 1 /* FieldType.Required */,\r\n    assembly: 0 /* FieldType.Default */,\r\n    fileName: 0 /* FieldType.Default */,\r\n    line: 0 /* FieldType.Default */\r\n});\r\nexport function _extractStackFrame(frame, level) {\r\n    var _a;\r\n    var theFrame;\r\n    if (frame && isString(frame) && strTrim(frame)) {\r\n        theFrame = (_a = {},\r\n            _a[_DYN_AI_DATA_CONTRACT /* @min:aiDataContract */] = stackFrameAiDataContract,\r\n            _a.level = level,\r\n            _a.assembly = strTrim(frame),\r\n            _a.method = NoMethod,\r\n            _a.fileName = \"\",\r\n            _a.line = 0,\r\n            _a.sizeInBytes = 0,\r\n            _a);\r\n        var idx = 0;\r\n        while (idx < _parseSequence[_DYN_LENGTH /* @min:%2elength */]) {\r\n            var sequence = _parseSequence[idx];\r\n            if (sequence.chk && !sequence.chk(frame)) {\r\n                break;\r\n            }\r\n            if (sequence.pre) {\r\n                frame = sequence.pre(frame);\r\n            }\r\n            // Attempt to \"parse\" the stack frame\r\n            var matches = frame[_DYN_MATCH /* @min:%2ematch */](sequence.re);\r\n            if (matches && matches[_DYN_LENGTH /* @min:%2elength */] >= sequence.len) {\r\n                if (sequence.m) {\r\n                    theFrame.method = strTrim(matches[sequence.m] || NoMethod);\r\n                }\r\n                if (sequence.hdl) {\r\n                    // Run any custom handler\r\n                    sequence.hdl(theFrame, sequence, matches);\r\n                }\r\n                else if (sequence.fn) {\r\n                    if (sequence.ln) {\r\n                        theFrame[_DYN_FILE_NAME /* @min:%2efileName */] = strTrim(matches[sequence.fn] || \"\");\r\n                        theFrame[_DYN_LINE /* @min:%2eline */] = parseInt(strTrim(matches[sequence.ln] || \"\")) || 0;\r\n                    }\r\n                    else {\r\n                        _parseFilename(theFrame, matches[sequence.fn] || \"\");\r\n                    }\r\n                }\r\n                // We found a match so stop looking\r\n                break;\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    return _populateFrameSizeInBytes(theFrame);\r\n}\r\nfunction _stackFrameFromInterface(frame) {\r\n    var _a;\r\n    var parsedFrame = (_a = {},\r\n        _a[_DYN_AI_DATA_CONTRACT /* @min:aiDataContract */] = stackFrameAiDataContract,\r\n        _a.level = frame.level,\r\n        _a.method = frame.method,\r\n        _a.assembly = frame[_DYN_ASSEMBLY /* @min:%2eassembly */],\r\n        _a.fileName = frame[_DYN_FILE_NAME /* @min:%2efileName */],\r\n        _a.line = frame[_DYN_LINE /* @min:%2eline */],\r\n        _a.sizeInBytes = 0,\r\n        _a);\r\n    return _populateFrameSizeInBytes(parsedFrame);\r\n}\r\nfunction _populateFrameSizeInBytes(frame) {\r\n    var sizeInBytes = STACKFRAME_BASE_SIZE;\r\n    if (frame) {\r\n        sizeInBytes += frame.method[_DYN_LENGTH /* @min:%2elength */];\r\n        sizeInBytes += frame.assembly[_DYN_LENGTH /* @min:%2elength */];\r\n        sizeInBytes += frame.fileName[_DYN_LENGTH /* @min:%2elength */];\r\n        sizeInBytes += frame.level.toString()[_DYN_LENGTH /* @min:%2elength */];\r\n        sizeInBytes += frame.line.toString()[_DYN_LENGTH /* @min:%2elength */];\r\n        frame[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = sizeInBytes;\r\n    }\r\n    return frame;\r\n}\r\nexport function _parsedFrameToInterface(frame) {\r\n    return {\r\n        level: frame.level,\r\n        method: frame.method,\r\n        assembly: frame[_DYN_ASSEMBLY /* @min:%2eassembly */],\r\n        fileName: frame[_DYN_FILE_NAME /* @min:%2efileName */],\r\n        line: frame[_DYN_LINE /* @min:%2eline */]\r\n    };\r\n}\r\n//# sourceMappingURL=Exception.js.map"],"names":[],"mappings":";;;;AAA4D;AAC1B;AAClC,8EAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}