{"version":3,"file":"StatsBeat.js.map","sources":["StatsBeat.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { arrForEach, isNumber, makeGlobRegex, objDefineProps, scheduleTimeout, strIndexOf, strLower, utcNow } from \"@nevware21/ts-utils\";\r\nimport { onConfigChange } from \"../Config/DynamicConfig\";\r\nimport { _DYN_CANCEL, _DYN_EXCEPTION, _DYN_FAILURE, _DYN_INDEX_OF, _DYN_IS_INITIALIZED, _DYN_REQUEST_DURATION, _DYN_THROTTLE, _DYN_TOTAL_REQUEST, _DYN_TYPE } from \"../__DynamicConstants\";\r\nimport { _throwInternal, safeGetLogger } from \"./DiagnosticLogger\";\r\nimport { isFeatureEnabled } from \"./HelperFuncs\";\r\nimport { STR_EMPTY } from \"./InternalConstants\";\r\nvar STATS_COLLECTION_SHORT_INTERVAL = 900000; // 15 minutes\r\nvar STATS_MIN_INTERVAL_SECONDS = 60; // 1 minute\r\nvar STATSBEAT_LANGUAGE = \"JavaScript\";\r\nvar STATSBEAT_TYPE = \"Browser\";\r\n/**\r\n * This function checks if the provided endpoint matches the provided urlMatch. It\r\n * compares the endpoint with the urlMatch in a case-insensitive manner and also checks\r\n * if the endpoint is a substring of the urlMatch. The urlMatch can also be a regex\r\n * pattern, in which case it will be checked against the endpoint using regex.\r\n * @param endpoint - The endpoint to check against the URL.\r\n * @param urlMatch - The URL to check against the endpoint.\r\n * @returns true if the URL matches the endpoint, false otherwise.\r\n */\r\nfunction _isMatchEndpoint(endpoint, urlMatch) {\r\n    var lwrUrl = strLower(urlMatch);\r\n    // Check if the endpoint is a substring of the URL\r\n    if (strIndexOf(endpoint, lwrUrl) !== -1) {\r\n        return true;\r\n    }\r\n    // If it looks like a regex pattern, check if the endpoint matches the regex\r\n    if (strIndexOf(lwrUrl, \"*\") != -1 || strIndexOf(lwrUrl, \"?\") != -1) {\r\n        // Check if the endpoint is a regex pattern\r\n        var regex = makeGlobRegex(lwrUrl);\r\n        if (regex.test(endpoint)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Creates a new INetworkStatsbeat instance with the specified host.\r\n * @param host - The host for the INetworkStatsbeat instance.\r\n * @returns A new INetworkStatsbeat instance.\r\n */\r\nfunction _createNetworkStatsbeat(host) {\r\n    return {\r\n        host: host,\r\n        totalRequest: 0,\r\n        success: 0,\r\n        throttle: {},\r\n        failure: {},\r\n        retry: {},\r\n        exception: {},\r\n        requestDuration: 0\r\n    };\r\n}\r\n/**\r\n * Creates a new IStatsBeat instance with the specified manager callbacks and statsbeat state.\r\n * @param mgr - The manager callbacks to use for the IStatsBeat instance.\r\n * @param statsBeatStats - The statsbeat state to use for the IStatsBeat instance.\r\n * @returns A new IStatsBeat instance.\r\n */\r\nfunction _createStatsBeat(mgr, statsBeatStats) {\r\n    var _networkCounter = _createNetworkStatsbeat(statsBeatStats.endpoint);\r\n    var _timeoutHandle; // Handle to the timer for sending telemetry. This way, we would not send telemetry when system sleep.\r\n    var _isEnabled = true; // Flag to check if statsbeat is enabled or not\r\n    function _setupTimer() {\r\n        if (_isEnabled && !_timeoutHandle) {\r\n            _timeoutHandle = mgr.start(function () {\r\n                _timeoutHandle = null;\r\n                trackStatsbeats();\r\n            });\r\n        }\r\n    }\r\n    function trackStatsbeats() {\r\n        if (_isEnabled) {\r\n            _trackSendRequestDuration();\r\n            _trackSendRequestsCount();\r\n            _networkCounter = _createNetworkStatsbeat(_networkCounter.host);\r\n            _timeoutHandle && _timeoutHandle[_DYN_CANCEL /* @min:%2ecancel */]();\r\n            _timeoutHandle = null;\r\n        }\r\n    }\r\n    /**\r\n     * This is a simple helper that checks if the currently reporting endpoint is the same as this instance was\r\n     * created with. This is used to ensure that we only send statsbeat events to the endpoint that was used\r\n     * when the instance was created. This is important as the endpoint can change during the lifetime of the\r\n     * instance and we don't want to send statsbeat events to the wrong endpoint.\r\n     * @param endpoint\r\n     * @returns true if the endpoint is the same as the one used to create the instance, false otherwise\r\n     */\r\n    function _checkEndpoint(endpoint) {\r\n        return _networkCounter.host === endpoint;\r\n    }\r\n    /**\r\n     * Attempt to send statsbeat events to the server. This is done by creating a new event and sending it to the core.\r\n     * The event is created with the name and value passed in, and any additional properties are added to the event as well.\r\n     * This will only send the event when\r\n     * - the statsbeat is enabled\r\n     * - the statsbeat key is set for the current endpoint\r\n     * - the value is greater than 0\r\n     * @param name - The name of the event to send\r\n     * @param val - The value of the event to send\r\n     * @param properties - Optional additional properties to add to the event\r\n     */\r\n    function _sendStatsbeats(name, val, properties) {\r\n        if (_isEnabled && val && val > 0) {\r\n            // Add extra properties\r\n            var baseProperties = {\r\n                \"rp\": \"unknown\",\r\n                \"attach\": \"Manual\",\r\n                \"cikey\": statsBeatStats.cKey,\r\n                \"os\": STATSBEAT_TYPE,\r\n                \"language\": STATSBEAT_LANGUAGE,\r\n                \"version\": statsBeatStats.sdkVer || \"unknown\",\r\n                \"endpoint\": \"breeze\",\r\n                \"host\": _networkCounter.host\r\n            };\r\n            // Manually merge properties instead of using spread syntax\r\n            var combinedProps = { \"host\": _networkCounter.host };\r\n            // Add properties if present\r\n            if (properties) {\r\n                for (var key in properties) {\r\n                    if (properties.hasOwnProperty(key)) {\r\n                        combinedProps[key] = properties[key];\r\n                    }\r\n                }\r\n            }\r\n            // Add base properties\r\n            for (var key in baseProperties) {\r\n                if (baseProperties.hasOwnProperty(key)) {\r\n                    combinedProps[key] = baseProperties[key];\r\n                }\r\n            }\r\n            var statsbeatEvent = {\r\n                name: name,\r\n                baseData: {\r\n                    name: name,\r\n                    average: val,\r\n                    properties: combinedProps\r\n                },\r\n                baseType: \"MetricData\"\r\n            };\r\n            mgr.track(statsBeat, statsbeatEvent);\r\n        }\r\n    }\r\n    function _trackSendRequestDuration() {\r\n        var totalRequest = _networkCounter[_DYN_TOTAL_REQUEST /* @min:%2etotalRequest */];\r\n        if (_networkCounter[_DYN_TOTAL_REQUEST /* @min:%2etotalRequest */] > 0) {\r\n            var averageRequestExecutionTime = _networkCounter[_DYN_REQUEST_DURATION /* @min:%2erequestDuration */] / totalRequest;\r\n            _sendStatsbeats(\"Request_Duration\", averageRequestExecutionTime);\r\n        }\r\n    }\r\n    function _trackSendRequestsCount() {\r\n        var currentCounter = _networkCounter;\r\n        _sendStatsbeats(\"Request_Success_Count\", currentCounter.success);\r\n        for (var code in currentCounter[_DYN_FAILURE /* @min:%2efailure */]) {\r\n            var count = currentCounter[_DYN_FAILURE /* @min:%2efailure */][code];\r\n            _sendStatsbeats(\"failure\", count, { statusCode: code });\r\n        }\r\n        for (var code in currentCounter.retry) {\r\n            var count = currentCounter.retry[code];\r\n            _sendStatsbeats(\"retry\", count, { statusCode: code });\r\n        }\r\n        for (var code in currentCounter[_DYN_EXCEPTION /* @min:%2eexception */]) {\r\n            var count = currentCounter[_DYN_EXCEPTION /* @min:%2eexception */][code];\r\n            _sendStatsbeats(\"exception\", count, { exceptionType: code });\r\n        }\r\n        for (var code in currentCounter[_DYN_THROTTLE /* @min:%2ethrottle */]) {\r\n            var count = currentCounter[_DYN_THROTTLE /* @min:%2ethrottle */][code];\r\n            _sendStatsbeats(\"Throttle_Count\", count, { statusCode: code });\r\n        }\r\n    }\r\n    function _setEnabled(isEnabled) {\r\n        _isEnabled = isEnabled;\r\n        if (!_isEnabled) {\r\n            if (_timeoutHandle) {\r\n                _timeoutHandle[_DYN_CANCEL /* @min:%2ecancel */]();\r\n                _timeoutHandle = null;\r\n            }\r\n        }\r\n    }\r\n    // THE statsbeat instance being created and returned\r\n    var statsBeat = {\r\n        enabled: !!_isEnabled,\r\n        endpoint: STR_EMPTY,\r\n        type: 0 /* eStatsType.SDK */,\r\n        count: function (status, payloadData, endpoint) {\r\n            if (_isEnabled && _checkEndpoint(endpoint)) {\r\n                if (payloadData && payloadData[\"statsBeatData\"] && payloadData[\"statsBeatData\"][\"startTime\"]) {\r\n                    _networkCounter[_DYN_TOTAL_REQUEST /* @min:%2etotalRequest */] = (_networkCounter[_DYN_TOTAL_REQUEST /* @min:%2etotalRequest */] || 0) + 1;\r\n                    _networkCounter[_DYN_REQUEST_DURATION /* @min:%2erequestDuration */] += utcNow() - payloadData[\"statsBeatData\"][\"startTime\"];\r\n                }\r\n                var retryArray = [401, 403, 408, 429, 500, 502, 503, 504];\r\n                var throttleArray = [402, 439];\r\n                if (status >= 200 && status < 300) {\r\n                    _networkCounter.success++;\r\n                }\r\n                else if (retryArray[_DYN_INDEX_OF /* @min:%2eindexOf */](status) !== -1) {\r\n                    _networkCounter.retry[status] = (_networkCounter.retry[status] || 0) + 1;\r\n                }\r\n                else if (throttleArray[_DYN_INDEX_OF /* @min:%2eindexOf */](status) !== -1) {\r\n                    _networkCounter[_DYN_THROTTLE /* @min:%2ethrottle */][status] = (_networkCounter[_DYN_THROTTLE /* @min:%2ethrottle */][status] || 0) + 1;\r\n                }\r\n                else if (status !== 307 && status !== 308) {\r\n                    _networkCounter[_DYN_FAILURE /* @min:%2efailure */][status] = (_networkCounter[_DYN_FAILURE /* @min:%2efailure */][status] || 0) + 1;\r\n                }\r\n                _setupTimer();\r\n            }\r\n        },\r\n        countException: function (endpoint, exceptionType) {\r\n            if (_isEnabled && _checkEndpoint(endpoint)) {\r\n                _networkCounter[_DYN_EXCEPTION /* @min:%2eexception */][exceptionType] = (_networkCounter[_DYN_EXCEPTION /* @min:%2eexception */][exceptionType] || 0) + 1;\r\n                _setupTimer();\r\n            }\r\n        }\r\n    };\r\n    // Make the properties readonly / reactive to changes\r\n    return objDefineProps(statsBeat, {\r\n        enabled: { g: function () { return _isEnabled; }, s: _setEnabled },\r\n        type: { g: function () { return statsBeatStats[_DYN_TYPE /* @min:%2etype */]; } },\r\n        endpoint: { g: function () { return _networkCounter.host; } }\r\n    });\r\n}\r\nfunction _getEndpointCfg(statsBeatConfig, type) {\r\n    var endpointCfg = null;\r\n    if (statsBeatConfig && statsBeatConfig.endCfg) {\r\n        arrForEach(statsBeatConfig.endCfg, function (value) {\r\n            if (value[_DYN_TYPE /* @min:%2etype */] === type) {\r\n                endpointCfg = value;\r\n                return -1; // Stop the loop if we found a match\r\n            }\r\n        });\r\n    }\r\n    return endpointCfg;\r\n}\r\n/**\r\n * This function retrieves the stats instrumentation key (iKey) for the given endpoint from\r\n * the statsBeatConfig. It iterates through the keys in the statsBeatConfig and checks if\r\n * the endpoint matches any of the URLs associated with that key. If a match is found, it\r\n * returns the corresponding iKey.\r\n * @param statsBeatConfig - The configuration object for StatsBeat.\r\n * @param endpoint - The endpoint to check against the URLs in the configuration.\r\n * @returns The iKey associated with the matching endpoint, or null if no match is found.\r\n */\r\nfunction _getIKey(endpointCfg, endpoint) {\r\n    var statsKey = null;\r\n    if (endpointCfg.keyMap) {\r\n        arrForEach(endpointCfg.keyMap, function (keyMap) {\r\n            if (keyMap.match) {\r\n                arrForEach(keyMap.match, function (url) {\r\n                    if (_isMatchEndpoint(url, endpoint)) {\r\n                        statsKey = keyMap.key || null;\r\n                        // Stop the loop if we found a match\r\n                        return -1;\r\n                    }\r\n                });\r\n            }\r\n            if (statsKey) {\r\n                // Stop the loop if we found a match\r\n                return -1;\r\n            }\r\n        });\r\n    }\r\n    return statsKey;\r\n}\r\nexport function createStatsMgr() {\r\n    var _isMgrEnabled = false; // Flag to check if statsbeat is enabled or not\r\n    var _core; // The core instance that is used to send telemetry\r\n    var _shortInterval = STATS_COLLECTION_SHORT_INTERVAL;\r\n    var _statsBeatConfig;\r\n    // Lazily initialize the manager and start listening for configuration changes\r\n    // This is also required to handle \"unloading\" and then re-initializing again\r\n    function _init(core, statsConfig, featureName) {\r\n        if (_core) {\r\n            // If the core is already set, then just return with an empty unload hook\r\n            _throwInternal(safeGetLogger(core), 2 /* eLoggingSeverity.WARNING */, 113 /* _eInternalMessageId.StatsBeatManagerException */, \"StatsBeat manager is already initialized\");\r\n            return null;\r\n        }\r\n        _core = core;\r\n        if (core && core[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\r\n            // Start listening for configuration changes from the core config, within a config change handler\r\n            // This will support the scenario where the config is changed after the statsbeat has been created\r\n            return onConfigChange(core.config, function (details) {\r\n                // Check the feature state again to see if it has changed\r\n                _isMgrEnabled = false;\r\n                if (statsConfig && isFeatureEnabled(statsConfig.feature, details.cfg, false) === true) {\r\n                    // Call the getCfg function to get the latest configuration for the statsbeat instance\r\n                    // This should also evaluate the throttling level and other settings for the statsbeat instance\r\n                    // to determine if it should be enabled or not.\r\n                    _statsBeatConfig = statsConfig.getCfg(core, details.cfg);\r\n                    if (_statsBeatConfig) {\r\n                        _isMgrEnabled = true;\r\n                        _shortInterval = STATS_COLLECTION_SHORT_INTERVAL; // Reset to the default in-case the config is removed / changed\r\n                        if (isNumber(_statsBeatConfig.shrtInt) && _statsBeatConfig.shrtInt > STATS_MIN_INTERVAL_SECONDS) {\r\n                            _shortInterval = _statsBeatConfig.shrtInt * 1000; // Convert to milliseconds\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    function _track(statsBeat, statsBeatEvent) {\r\n        if (_isMgrEnabled && _statsBeatConfig) {\r\n            var endpoint = statsBeat.endpoint;\r\n            var sendEvt = !!statsBeat[_DYN_TYPE /* @min:%2etype */];\r\n            // Fetching the stats key for the endpoint here to support the scenario where the endpoint is changed\r\n            // after the statsbeat instance is created. This will ensure that the correct stats key is used for the endpoint.\r\n            // It also avoids the tracking of the statsbeat event if the endpoint is not in the config.\r\n            var endpointCfg = _getEndpointCfg(_statsBeatConfig, statsBeat[_DYN_TYPE /* @min:%2etype */]);\r\n            if (endpointCfg) {\r\n                // Check for key remapping\r\n                var statsKey = _getIKey(endpointCfg, endpoint);\r\n                if (statsKey) {\r\n                    // Using this iKey for the statsbeat event\r\n                    statsBeatEvent.iKey = statsKey;\r\n                    // We have specific config for this endpoint, so we can send the event\r\n                    sendEvt = true;\r\n                }\r\n                if (sendEvt) {\r\n                    _core.track(statsBeatEvent);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function _createInstance(state) {\r\n        var instance = null;\r\n        if (_isMgrEnabled) {\r\n            var callbacks = {\r\n                start: function (cb) {\r\n                    return scheduleTimeout(cb, _shortInterval);\r\n                },\r\n                track: _track\r\n            };\r\n            instance = _createStatsBeat(callbacks, state);\r\n        }\r\n        return instance;\r\n    }\r\n    var theMgr = {\r\n        enabled: false,\r\n        newInst: _createInstance,\r\n        init: _init\r\n    };\r\n    return objDefineProps(theMgr, {\r\n        \"enabled\": { g: function () { return _isMgrEnabled; } }\r\n    });\r\n}\r\n//# sourceMappingURL=StatsBeat.js.map"],"names":[],"mappings":";;;;AAA4D;AAC1B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"}